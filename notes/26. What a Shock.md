# FireBolt Projectile Spread

## 火球的散布

同时发射多颗火球的时候分散一下

### 在` AuraFireBolt`里处理

大体上参考`AuraProjectileSpell::SpawnProjectile`，生成的火球的Spread可以参考之前Shaman召唤Deamon的时候用的方法

`HomingTarget`是被技能选中的那个目标，要作为火球的MovementComponent的终点



```cpp
public:
	UFUNCTION(BlueprintCallable)
	void SpawnProjectiles(const FVector& ProjectileTargetLocation, const FGameplayTag& SocketTag, bool bOverridePitch, float PitchOverride, AActor* HomingTarget);

protected:
	UPROPERTY(EditDefaultsOnly, Category = "FireBolt")
	float ProjectileSpread = 90.f;

	UPROPERTY(EditDefaultsOnly, Category = "FireBolt")
	int32 MaxNumProjectiles = 5;
```



```cpp
#include "Kismet/KismetSystemLibrary.h"


void UAuraFireBolt::SpawnProjectiles(const FVector& ProjectileTargetLocation, const FGameplayTag& SocketTag, bool bOverridePitch, float PitchOverride, AActor* HomingTarget)
{
    const bool bIsServer = GetAvatarActorFromActorInfo()->HasAuthority();
    if(!bIsServer)
    {
        return;
    }
    
    const FVector SocketLocation = ICombatInterface::Execute_GetCombatSocketLocation(GetAvatarActorFromActorInfo(), SocketTag);
    FRotator Rotation = (ProjectileTargetLocation - SocketLocation).Rotation();
    if(bOverridePitch)
    {
        Rotation.Pitch = PitchOverride;
    }
    
    const FVector Forward = Rotation.Vector();
    const FVector LeftOfSpread = Forward.RotateAngleAxis(-ProjectileSpread / 2.0f, FVector::UpVector);
    const FVector RightOfSpread = Forward.RotateAngleAxis(ProjectileSpread / 2.0f, FVector::UpVector);
    
    if(NumProjectiles > 1)
    {
        const float DeltaSpread = ProjectileSpread / (NumProjectiles - 1);
        for(int32 i = 0; i != NumProjectiles; ++i)
        {
            const FVector Direction = LeftOfSpread.RotateAngleAxis(DeltaSpread * i, FVector::UpVector);
            const FVector Start = SocketLocation + FVector(0,0,5);
			UKismetSystemLibrary::DrawDebugArrow(
				GetAvatarActorFromActorInfo(),
				Start,
				Start + Direction * 75.f,
				1,
				FLinearColor::Red,
				120,
				1
            );
        }
    }
    else
    {
        const FVector Start = SocketLocation + FVector(0,0,5);
		UKismetSystemLibrary::DrawDebugArrow(
            GetAvatarActorFromActorInfo(),
            Start,
            Start + Forward * 75.f,
            1,
            FLinearColor::Red,
            120,
            1
        );
    }
    
    UKismetSystemLibrary::DrawDebugArrow(GetAvatarActorFromActorInfo(), SocketLocation, SocketLocation + Forward * 100.f, 1, FLinearColor::White, 120, 1);
	UKismetSystemLibrary::DrawDebugArrow(GetAvatarActorFromActorInfo(), SocketLocation, SocketLocation + LeftOfSpread * 100.f, 1, FLinearColor::Gray, 120, 1);
	UKismetSystemLibrary::DrawDebugArrow(GetAvatarActorFromActorInfo(), SocketLocation, SocketLocation + RightOfSpread * 100.f, 1, FLinearColor::Gray, 120, 1);
}
```



### 在`GA_FireBolt`里处理

原本调用的`SpawnProjectile`改成`SpawnProjectiles`





# Spawning Multiple Projectiles

## 产生多个火球

### 在` AuraAbilitySystemLibrary`里处理

把根据Forward和Spread产生多个角度的部分改成一个函数

```cpp
public:
	UFUNCTION(BlueprintPure, Category = "AuraAbilitySystemLibrary|GameplayMechanics")
	static TArray<FRotator> EvenlySpacedRotators(const FVector& Forward, const FVector& Axis, float Spread, int32 NumRotators);

	UFUNCTION(BlueprintPure, Category = "AuraAbilitySystemLibrary|GameplayMechanics")
	static TArray<FVector> EvenlyRotatedVectors(const FVector& Forward, const FVector& Axis, float Spread, int32 NumVectors);
```



```cpp
TArray<FRotator> UAuraAbilitySystemLibrary::EvenlySpacedRotators(const FVector& Forward, const FVector& Axis, float Spread, int32 NumRotators)
{
    TArray<FRotator> Rotators;
    const FVector LeftOfSpread = Forward.RotateAngleAxis(-Spread / 2.0f, Axis);
    if (NumRotators > 1)
	{
		const float DeltaSpread = Spread / (NumRotators - 1);
		for (int32 i = 0; i < NumRotators; i++)
		{
			const FVector Direction = LeftOfSpread.RotateAngleAxis(DeltaSpread * i, FVector::UpVector);
			Rotators.Add(Direction.Rotation());
		}
	}
	else
	{
		Rotators.Add(Forward.Rotation());
	}
    
    return Rotators;
}

TArray<FVector> UAuraAbilitySystemLibrary::EvenlyRotatedVectors(const FVector& Forward, const FVector& Axis, float Spread, int32 NumVectors)
{
    TArray<FVector> Vectors;
	
	const FVector LeftOfSpread = Forward.RotateAngleAxis(-Spread / 2.0f, Axis);
	if (NumVectors > 1)
	{
		const float DeltaSpread = Spread / (NumVectors - 1);
		for (int32 i = 0; i < NumVectors; i++)
		{
			const FVector Direction = LeftOfSpread.RotateAngleAxis(DeltaSpread * i, FVector::UpVector);
			Vectors.Add(Direction);
		}
	}
	else
	{
		Vectors.Add(Forward);
	}
	return Vectors;
}
```



### 在` AuraFireBolt`里处理

```cpp
#include "AbilitySystem/AuraAbilitySystemLibrary.h"
#include "Actor/AuraProjectile.h"


void UAuraFireBolt::SpawnProjectiles(const FVector& ProjectileTargetLocation, const FGameplayTag& SocketTag, bool bOverridePitch, float PitchOverride, AActor* HomingTarget)
{
    // ...
    const FVector Forward = Rotation.Vector();
    // TArray<FVector> Directions = UAuraAbilitySystemLibrary::EvenlyRotatedVectors(Forward, FVector::UpVector, ProjectileSpread, NumProjectiles);
    TArray<FRotator> Rotations = UAuraAbilitySystemLibrary::EvenlySpacedRotators(Forward, FVector::UpVector, ProjectileSpread, NumProjectiles);
    
    for(const FRotator& Rot : Rotations)
    {
        FTransform SpawnTransform;
        SpawnTransform.SetLocation(SocketLocation);
        SpawnTransform.SetRotation(Rot.Quaternion());
        
        AAuraProjectile* Projectile = GetWorld()->SpawnActorDeferred<AAuraProjectile>(
            ProjectileClass,
            SpawnTransform,
            GetOwningActorFromActorInfo(),
            Cast<APawn>(GetOwningActorFromActorInfo()),
            ESpawnActorCollisionHandlingMethod::AlwaysSpawn
        );
        
        Projectile->DamageEffectParams = MakeDamageEffectParamsFromClassDefaults();
        Projectile->FinishSpawning(SpawnTransform);
    }
   
    /*
    for(FVector& Direction : Directions)
    {
        UKismetSystemLibrary::DrawDebugArrow(
			GetAvatarActorFromActorInfo(),
			SocketLocation,
			SocketLocation + Direction * 75.f,
			1,
			FLinearColor::Red,
			120,
			1
		);
    }
    
    for(FRotator& Rot : Rotations)
    {
        const FVector Start = SocketLocation + FVector(0, 0, 5);
        UKismetSystemLibrary::DrawDebugArrow(
			GetAvatarActorFromActorInfo(),
			Start,
			Start + Rot.Vector() * 75.f,
			1,
			FLinearColor::Blue,
			120,
			1
		);
    }
    */
}
```





# Homing Projectiles

## 引导火球能运动到指定的落点

### 在` AuraProjectile `里处理

加个SceneComponent作为点击的不是敌人时火球的落点，主要是因为`Projectile->ProjectileMovement->HomingTargetComponent`是个WeakPtr，要考虑指定的TargetComponent的垃圾回收的问题，最后决定放在` AuraProjectile `里，用的时候再赋值为落点

```cpp
public:
	UPROPERTY()
	TObjectPtr<USceneComponent> HomingTargetSceneComponent;
```



### 在` AuraFireBolt `里处理

加速度取个随机值，这样到达落点有先后

```cpp
protected:
	UPROPERTY(EditDefaultsOnly, Category = "FireBolt")
	float HomingAccelerationMin = 1600.f;

	UPROPERTY(EditDefaultsOnly, Category = "FireBolt")
	float HomingAccelerationMax = 3200.f;

	UPROPERTY(EditDefaultsOnly, Category = "FireBolt")
	bool bLaunchHomingProjectiles = true;
```



```cpp
#include "GameFramework/ProjectileMovementComponent.h"

void UAuraFireBolt::SpawnProjectiles(const FVector& ProjectileTargetLocation, const FGameplayTag& SocketTag, bool bOverridePitch, float PitchOverride, AActor* HomingTarget)
{
    const int32 EffectiveNumProjectiles = FMath::Min(NumProjectiles, GetAbilityLevel());
	TArray<FRotator> Rotations = UAuraAbilitySystemLibrary::EvenlySpacedRotators(Forward, FVector::UpVector, ProjectileSpread, EffectiveNumProjectiles);
    
    // ...
    Projectile->DamageEffectParams = MakeDamageEffectParamsFromClassDefaults();
    
    if (HomingTarget && HomingTarget->Implements<UCombatInterface>())
    {
        Projectile->ProjectileMovement->HomingTargetComponent = HomingTarget->GetRootComponent();
    }
    else
    {
        Projectile->HomingTargetSceneComponent = NewObject<USceneComponent>(USceneComponent::StatisClass());
        Projectile->HomingTargetSceneComponent->SetWorldLocation(ProjectileTargetLocation);
        Projectile->ProjectileMovement->HomingTargetComponent = Projectile->HomingTargetSceneComponent;
    }
     Projectile->ProjectileMovement->HomingAccelerationMagnitude = FMath::FRandRange(HomingAccelerationMin, HomingAccelerationMax);
    Projectile->ProjectileMovement->bIsHomingProjectile = bLaunchHomingProjectiles;
    
    Projectile->FinishSpawning(SpawnTransform);
}
```



### 在`GA_FireBolt`里处理

`SpawnProjectiles`的时候打开PitchOverride并设置为45

`HitResult`的`HitActor`给提升为变量命名为`MouseHitActor`作为`HomingTarget`



### 在`BP_FireBolt`里处理

`Projectile Gravity Scale`改成0，这样可以确保在有引导的前提下命中目标

`Initial Speed`改低一点比如100这样不会打不中贴脸的敌人，`Max Speed`改成650







# Click Niagara System

## 鼠标点击的时候加个特效

### 在` AuraPlayerController `里处理

```cpp
private:
	UPROPERTY(EditDefaultsOnly)
	TObjectPtr<UNiagaraSystem> ClickNiagaraSystem;
```



```cpp
#include "NiagaraFunctionLibrary.h"

void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
{
    // ...
    if (FollowTime <= ShortPressThreshold && ControlledPawn)
    {
        // ...
        UNiagaraFunctionLibrary::SpawnSystemAtLocation(this, ClickNiagaraSystem, CachedDestination);
    }
}
```



### 在` BP_AuraPlayerController `里配置

`ClickNiagaraSystem`选择`FX_Cursor`





# Invoke Replicated Event

## 处理一下子弹的一些bug

### 在` AuraProjectile `里处理

删一下多余的音效

```cpp
void AAuraProjectile::OnHit()
{
    // ...
    if (LoopingSoundComponent)
	{
		LoopingSoundComponent->Stop();
		LoopingSoundComponent->DestroyComponent();
	}
}

void AAuraProjectile::Destroyed()
{
    if (LoopingSoundComponent)
	{
		LoopingSoundComponent->Stop();
		LoopingSoundComponent->DestroyComponent();
	}
    // ...
}
```



### 在`Dungeon.umap`里处理

`BlockingVolume`都设置一下对Visibility的Block Response Channel，对Projectile则是Overlap的

顺便把他们在Outliner中单独开个文件夹命名为`BlockingVolumes`



### 在`GA_FireBolt`里处理

给引导的加速度设置高一些，这样也可以减少对近处目标的不稳定性



## 用`InvokeReplicatedEvent`通知技能来区分按下和松开事件

### 在` CombatInterface `里处理

加个蓝图可实现的函数来设置是否在施法

```cpp
public:
	UFUNCTION(BlueprintImplementableEvent, BlueprintCallable)
	void SetInShockLoop(bool bInLoop);
```



### 在` AuraAbilitySystemComponent `里处理

调用`InvokeReplicatedEvent`通知蓝图InputTagReleased

```cpp
public:
	void AbilityInputTagPressed(const FGameplayTag& InputTag);
```



```cpp
void UAuraAbilitySystemComponent::AbilityInputTagPressed(const FGameplayTag& InputTag)
{
    if (!InputTag.IsValid())
	{
		return;
	}

	for (FGameplayAbilitySpec& AbilitySpec : GetActivatableAbilities())
	{
		if (AbilitySpec.DynamicAbilityTags.HasTagExact(InputTag))
		{
			AbilitySpecInputPressed(AbilitySpec);
			if (AbilitySpec.IsActive())
			{
				InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputPressed, AbilitySpec.Handle, AbilitySpec.ActivationInfo.GetActivationPredictionKey());
			}
		}
	}
    
}

void UAuraAbilitySystemComponent::AbilityInputTagReleased(const FGameplayTag& InputTag)
{
    // ...
    if (AbilitySpec.DynamicAbilityTags.HasTagExact(InputTag) && AbilitySpec.IsActive())
    {
        AbilitySpecInputReleased(AbilitySpec);
        InvokeReplicatedEvent(EAbilityGenericReplicatedEvent::InputReleased, AbilitySpec.Handle, AbilitySpec.ActivationInfo.GetActivationPredictionKey());
    }
}
```



### 在` AuraPlayerController `里处理

```cpp
void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
{
    // ...
    if (GetASC())
    {
        GetASC()->AbilityInputTagPressed(InputTag);
    }
}
```



### 在`BP_AuraCharacter`里处理

加个bool类型的变量命名为`InShockLoop`设置为蓝图可编辑

方便测试，把`GA_Electrocute`加到`StartupAbilities`里



### 在`ABP_Aura`里处理

在`Event Graph`里UpdateAnimation的Sequence->`BPAuraCharacter`的`InShockLoop`给提升为变量

`MainStates`加个`Cast_Shock_Loop`，转换规则是`InShockLoop`



### 在`GA_Electrocute`里处理

`StartupInputTag`设置为`InputTag.RMB`

`Event ActivateAbility`->`WaitInputRelease`的`OnRelease`->`Delay`10秒->`End Ability`

`WaitInputRelease`之后立刻->`Wait Input Press`选中`Test Already Released`

![1712401048242](E:\Typora\TyporaPic\1712401048242.png)





# Aura Beam Spell

## 光柱技能

### 创建` AuraBeamSpell`类

放在` Aura\Public\AbilitySystem\Abilities `下

继承自` AuraDamageGameplayAbility `

在蓝图中调用`Store`函数把鼠标选中的坐标和Actor以及拥有该技能的PlayerController都存一下以便后续使用，如果鼠标当前没命中，则取消技能

```cpp
public:
	UFUNCTION(BlueprintCallable)
	void StoreMouseDataInfo(const FHitResult& HitResult);

	UFUNCTION(BlueprintCallable)
	void StoreOwnerPlayerController();
protected:

	UPROPERTY(BlueprintReadWrite, Category = "Beam")
	FVector MouseHitLocation;

	UPROPERTY(BlueprintReadWrite, Category = "Beam")
	TObjectPtr<AActor> MouseHitActor;

	UPROPERTY(BlueprintReadWrite, Category = "Beam")
	TObjectPtr<APlayerController> OwnerPlayerController;
```



```cpp
void UAuraBeamSpell::StoreMouseDataInfo(const FHitResult& HitResult)
{
    if (HitResult.bBlockingHit)
    {
        MouseHitLocation = HitResult.ImpactPoint;
    	MouseHitActor = HitResult.GetActor();
    }
    else
    {
        CancelAbility(CurrentSpecHandle, CurrentActorInfo, CurrentActivationInfo, true);
    }
    
}

void UAuraBeamSpell::StoreOwnerPlayerController()
{
    if(CurrentActorInfo)
    {
        OwnerPlayerController = CurrentActorInfo->PlayerController.Get();
    }
    
}
```



### 在`GA_Electrocute`里处理

`ParentClass`改成` AuraBeamSpell`

加个`Anim Montage`的`Object Reference`类型的变量命名为`Montage_Electrocute`

把`Event Graph`里其他的都删了

`Event ActivateAbility`->`TargetDataUnderMouse`的`ValidData`->`DataHandle`的`GetHitResultFromTargetData`给`StoreMouseDataInfo`->`StoreOwnerPlayerController`->加个`Sequence`

首先`OwnerPlayerController`的`ShowMouseCursor`为false

然后`WaitInputRelease`的`OnRelease`->`OwnerPlayerController`的`ShowMouseCursor`为true->`End Ability`

![1712402770491](E:\Typora\TyporaPic\1712402770491.png)



![1712402777282](E:\Typora\TyporaPic\1712402777282.png)





# Electrocute Montage

## 播放电流的Montage

### 在` AuraBeamSpell `里处理

` StoreOwnerPlayerController `改一下改成`StoreOwnerVariables`

```cpp
public:
	void StoreOwnerVariables();

protected:
	UPROPERTY(BlueprintReadWrite, Category = "Beam")
	TObjectPtr<ACharacter> OwnerCharacter;
```



```cpp
#include "GameFramework/Character.h"

void UAuraBeamSpell::StoreOwnerVariables()
{
	if (CurrentActorInfo)
	{
		OwnerPlayerController = CurrentActorInfo->PlayerController.Get();
		OwnerCharacter = Cast<ACharacter>(CurrentActorInfo->AvatarActor);
	}
}
```



### 在`Cast_Shock`里处理

`EnableRootMotion`打开



### 加个GameplayTag

在`Project Settings`里加个` Event.Montage.Electrocute`



### 创建` AM_Cast_Electrocute`

放在` Content\Assets\Characters\Aura\Animations\Abilities `下

从`Cast_Shock`转过来

`Blend In`和`Blend Out`的`Blend Time`都改成0.01

Notifies加个`Motion Warpping`再加个`Event`

`Motion Warpping`在第0帧到第3帧`Add Notify State`选择`MotionWarpping`，`WarpTargetName`填`FacingTarget`，取消勾选`Warp Translation`，`RotationType`改成`Facing`

`Event`在第4帧`Add Notify`选择`AN_MontageEvent`，`Event Tag`选择` Event.Montage.Electrocute `



### 在` GA_Electrocute `里处理

`Montage_Electrocute`选择` AM_Cast_Electrocute`

`Event ActivateAbility`的开头->`GetAvatarActorFromActorInfo`的`Does Implement Interface`选`CombatInterface`为true才继续，false直接`EndAbility`，包裹起来命名为`EnforceImplementsCombatInterface`

`Set ShowMouseCursor`为false->`Update Facing Target`用`GetAvatarActorFromActorInfo`和`MouseHitLocation`->`PlayMontageAndWait`用`Montage_Electrocute`并取消选择`StopWhenAbilityEnds`->`WaitGameplayEvent`的Tag选` Event.Montage.Electrocute `选中`Only Trigger Once`和`Only Match Exact`

`WaitGameplayEvent`的`Event Received`->`GetAvatarActorFromActorInfo`的`SetInShockLoop`为true->`OwnerCharacter`的`GetCharacterMovement`的`DisableMovement`，包裹起来命名为`InShockLoop`

`Set ShowMouseCursor`为true->`GetAvatarActorFromActorInfo`的`SetInShockLoop`为false->`OwnerCharacter`的`GetCharacterMovement`的`SetMovementMode`为Walking，包裹起来命名为`PrepareToEndAbility`



![1712404860363](E:\Typora\TyporaPic\1712404860363.png)



### 在`BP_AuraCharacter`里处理

`Event Set in Shock Loop`设置`InShockLoop`



### 在` ABP_Aura `里处理

`Cast_Shock_Loop`->`Idle`的`Blend Settings Duration`改成0.2





# Player Block Tags

## 阻止玩家输入状态的GameplayTag

用来阻止当按住右键释放雷电攻击的时候还能shift+鼠标左键搓火球



### 在` AuraGameplayTags `里处理

```cpp
public:
	FGameplayTag Player_Block_InputPressed;
	FGameplayTag Player_Block_InputHeld;
	FGameplayTag Player_Block_InputReleased;
	FGameplayTag Player_Block_CursorTrace;
```



```cpp
void FAuraGameplayTags::InitializeNativeGameplayTags()
{
    // ...
    /*
	 * Player Tags
	 */

	GameplayTags.Player_Block_CursorTrace = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Player.Block.CursorTrace"),
		FString("Block tracing under the cursor")
	);

	GameplayTags.Player_Block_InputHeld = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Player.Block.InputHeld"),
		FString("Block Input Held callback for input")
	);

	GameplayTags.Player_Block_InputPressed = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Player.Block.InputPressed"),
		FString("Block Input Pressed callback for input")
	);

	GameplayTags.Player_Block_InputReleased = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Player.Block.InputReleased"),
		FString("Block Input Released callback for input")
	);
}
```



### 在` AuraPlayerController `里处理



```cpp
void AAuraPlayerController::CursorTrace()
{
    if(GetASC() && GetASC()->HasMatchingGameplayTag(FAuraGameplayTags::Get().Player_Block_CursorTrace))
    {
        if (LastActor)
        {
            LastActor->UnHighlightActor();
            LastActor = nullptr;
        }
		if (ThisActor) 
        {
            ThisActor->UnHighlightActor();
            ThisActor = nullptr;
        }
		
        return;
    }
    // ...
}

void AAuraPlayerController::AbilityInputTagPressed(FGameplayTag InputTag)
{
    if(GetASC() && GetASC()->HasMatchingGameplayTag(FAuraGameplayTags::Get().Player_Block_InputPressed))
    {
        return;
    }
    // ...
}

void AAuraPlayerController::AbilityInputTagReleased(FGameplayTag InputTag)
{
    if(GetASC() && GetASC()->HasMatchingGameplayTag(FAuraGameplayTags::Get().Player_Block_InputReleased))
    {
        return;
    }
    // ...
    if (UNavigationPath* NavPath = UNavigationSystemV1::FindPathToLocationSynchronously(this, ControlledPawn->GetActorLocation(), CachedDestination))
    {
        // ...
        if (GetASC() && !GetASC()->HasMatchingGameplayTag(FAuraGameplayTags::Get().Player_Block_InputPressed))
        {
            UNiagaraFunctionLibrary::SpawnSystemAtLocation(this, ClickNiagaraSystem, CachedDestination);
        }
    }
    
}

void AAuraPlayerController::AbilityInputTagHeld(FGameplayTag InputTag)
{
    if(GetASC() && GetASC()->HasMatchingGameplayTag(FAuraGameplayTags::Get().Player_Block_InputHeld))
    {
        return;
    }
    // ...
}

void AAuraPlayerController::Move(const FInputActionValue& InputActionValue)
{
    if(GetASC() && GetASC()->HasMatchingGameplayTag(FAuraGameplayTags::Get().Player_Block_InputPressed))
    {
        return;
    }
}
```



### 在`GA_Electrocute`里配置

`Activation Owned Tags`里添加`Player.Block.CursorTrace`、`Player.Block.InputHeld`和`Player.Block.InputPressed`





# GameplayCue Notify Paths

## 用`GameplayCue`处理技能的显示

### 在`Project Settings`里加个GameplayTag用来处理Cue

` GameplayCue.ShockBurst`



### 创建` GC_ShockBurst`

放在` Content\Blueprints\AbilitySystem\GameplayCueNotifies `下

继承自`GameplayCueNotify_Static`

`GameplayCueTag`选择` GameplayCue.ShockBurst `

Override一个`OnExecute`函数->`MyTarget`的`GetActorLocation`->`PlaySoundAtLocation`，`Sound`选择`sfx_Shock`



### 把` GC_MeleeImpact `挪到`GameplayCueNotifies `路径下



### 在` GA_Electrocute `里处理

`UpdateFacingTarget`->`ExecuteGameplayCueOnOwner`的`GameplayCueTag`选择` GameplayCue.ShockBurst `



### 在` AM_Cast_Electrocute `里处理

`Rate Scale`改成0.55

`Blend Time`改成0.2



### 在` DefaultGame.ini`里处理

指定某个路径告知编辑器在哪能找到GameplayCue

```ini
[/Script/GameplayAbilities.AbilitySystemGlobals]
+GameplayCueNotifyPaths=/Game/Blueprints/AbilitySystem/GameplayCueNotifies
```



### 在` DefaultEngine.ini`里处理

指定每次网络更新的时候能同步多少个RPC

在`GameplayCueManager.cpp`里的`CheckForTooManyRPCs`里会使用

```ini
[ConsoleVariables]
net.MaxRPCPerNetUpdate=10
```





# Gameplay Cue Notify Actor

## 加个循环播放的GameplayCue

### 在` CombatInterface `里处理

加个接口获取武器的Component

```cpp
public:
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable)
	USkeletalMeshComponent* GetWeapon();
```



### 在` AuraCharacterBase `里处理

```cpp
public:
	virtual USkeletalMeshComponent* GetWeapon_Implementation() override;
```



```cpp
USkeletalMeshComponent* AAuraCharacterBase::GetWeapon_Implementation()
{
	return Weapon;
}
```



### 在`Project Settings`里加个GameplayTag用来处理Cue

` GameplayCue.ShockLoop`



### 创建` GC_ShockLoop`

放在` Content\Blueprints\AbilitySystem\GameplayCueNotifies `下

继承自`GameplayCueNotify_Actor`

`GameplayCueTag`选择` GameplayCue.ShockLoop`

选中`Auto Destroy on Remove`这样实际的Instance实例才会销毁而不是复用

Override一个`While Active`的函数，把`Paramters`给Break开->`SpawnSystemAttached`的`AttachToComponent`用Break开的`TargetAttachComponent`，`AttachPointName`填`TipSocket`，`SystemTemplate`选择`NS_ElectricBeam`->`Promote to Variable`命名为`BeamSystem`->`SetNiagaraVariable(Vector3)`的`InVariableName`填`Beam End`用Break的`Location`

![1712561516590](E:\Typora\TyporaPic\1712561516590.png)

![1712561523253](E:\Typora\TyporaPic\1712561523253.png)



Override一个`OnRemove`函数->`BeamSystem`右击选择`Convert to Validated Get`如果为Valid->`DestroyComponent`

![1712561506142](E:\Typora\TyporaPic\1712561506142.png)



### 在` GA_Electrocute `里处理

`InShockLoop`->`AddGameplayCueOnActor(Looping)`的`GameplayCueTag`选择` GameplayCue.ShockLoop`，Target选择`GetAvatarActorFromActorInfo`，Parameters直接先`MakeGameplayCueParameters`，`TargetAttachComponent`选择`GetAvatarActorFromActorInfo`的`GetWeapon`，`Location`填`GetMouseHitLocation`

![1712561483110](E:\Typora\TyporaPic\1712561483110.png)

`PreparetoEndAbility`里的最后->`RemoveGameplayCueFromOwner`，`GameplayCueTag`选择` GameplayCue.ShockLoop`

![1712561496566](E:\Typora\TyporaPic\1712561496566.png)





# Electrocute Looping Sound

## 循环的时候加个声音

### 在` GC_ShockLoop `里处理

`WhileActive`的`SetNiagaraVariable`->`SpawnSoundAttached`的`Sound`选择`sfx_ShockLoop`，`AttachToComponent`用`TargetAttachComponent`，选中`Stop when Attached to Destroyed`和`Auto Destroy`->`Promote to Variable`命名为`ShockLoopSound`

![1712562137320](E:\Typora\TyporaPic\1712562137320.png)

`OnRemove`的时候`ShockLoopSound`右击选择`Convert to Validated Get`如果为Valid->`FadeOut`的`FadeOutDuration`填0.3

![1712562108145](E:\Typora\TyporaPic\1712562108145.png)



## 客户端看其他角色并没有持续性的释放技能横置法杖的动作

因为`ABP_Aura`没有同步更新`InShockedLoop`

### 在`BP_AuraCharacter`里处理

`InShockedLoop`设置Replication为`Replicated`





# Target Trace Channel

## 加个TargetTrace的CollisionChannel

这样雷电射线在墙体之类的地方的落点就是正确的位置了

### 在`ProjectSettings`里加个新的碰撞通道

`Engine-Collision`里，`New Object Channel`然后Name填`Target`，`DefaultResponse`填`Block`



### 在` Aura.h`里处理

```cpp
#define ECC_Target ECollisionChannel::ECC_GameTraceChannel2
```



### 在` TargetDataUnderMouse `里处理

```cpp
#include "Aura/Aura.h"

void UTargetDataUnderMouse::SendMouseCursorData()
{
    // ...
    PC->GetHitResultUnderCursor(ECC_Target, false, CursorHit);
}
```



### 在`Dungeon.map`里处理

`BlockingVolume`要忽略`TargetChannel`



### 在`BP_Auracharacter`里处理

`Box`也要忽略`TargetChannel`



### 在` BP_FadeActor `里处理

`FadeFinished`的输入如果<=0->`SetCollisionResponsetoChannel`把`Target`设置为Ignore

如果>=1->`SetCollisionResponsetoChannel`把`Target`设置为Block

![1712563450725](E:\Typora\TyporaPic\1712563450725.png)



## 有些StaticMesh当摄像机在其边缘的时候会FadeOutFadeIn多次

`CollisionComplexity`改成`Project Default`，然后重新`Add Box Simplified Collision`





# First Trace Target

## 第一个被雷电射线打到的目标

### 在` AuraBeamSpell `里处理

从角色的武器开始，到`BeamTargetLocation`为止做个SphereTrace查询

```cpp
public:
	UFUNCTION(BlueprintCallable)
	void TraceFirstTarget(const FVector& BeamTargetLocation);
```



```cpp
#include "Kismet/KismetSystemLibrary.h"

void UAuraBeamSpell::TraceFirstTarget(const FVector& BeamTargetLocation)
{
    check(OwnerCharacter);
    if(OwnerCharacter->Implements<UCombatInterface>())
    {
        if(USkeletalMeshComponent* Weapon = ICombatInterface::Execute_GetWeapon(OwnerCharacter))
        {
            TArray<AActor*> ActorsToIgnore;
            ActorsToIgnore.Add(OwnerCharacter);
            FHitResult HitResult;
            const FVector SocketLocation = Weapon->GetSocketLocation(FName("TipSocket"));
            UKismetSystemLibrary::SphereTraceSingle(
                OwnerCharacter, 
                SocketLocation, 
                BeamTargetLocation,
                10.0f, 
                TraceTypeQuery1,
                false,
                ActorsToIgnore,
                EDrawDebugTrace::None, //ForDuration,
                HitResult,
                true
            );
            
            if(HitResult.bBlockingHit)
            {
                MouseHitLocation = HitResult.ImpactPoint;
                MouseHitActor = HitResult.GetActor();
            }
        }
    }
}
```



### 在` GA_Electrocute `里处理

把之前`GetWeapon`->`AddGameplayCueOnActor(Looping)`给包裹起来命名为`SpawnElectricBeam`的函数，`AddGameplayCueOnActor`的`Target`给`Promote to local Variable`命名为`CueTarget`

`SpawnElectricBeam`->`TraceFirstTarget`用`MouseHitLocation`->`MakeGameplayCueParameter`的`Location`用`MouseHitLocation`，`SourceObject`选择`MouseHitActor`，`TargetAttachComponent`用`OwnerCharacter`的`GetWeapon`->`Promote to Variable`命名为`FirstTargetCueParams`->`MouseHitActor`的`DoseImplementInterface`选择`CombatInterface`给`Promote to Variable`命名为`FirstTargetImplementsInterface`

如果为true->`CueTarget`设置为`MouseHitActor`

如果为false->`CueTarget`设置为`GetAvatarActorFromActorInfo`

->`AddGameplayCueOnActor`的`Target`用`CueTarget`，`Parameters`用`FirstTargetCueParams`

![1712566993585](E:\Typora\TyporaPic\1712566993585.png)

![1712567008230](E:\Typora\TyporaPic\1712567008230.png)

![1712567012952](E:\Typora\TyporaPic\1712567012952.png)



在`PrepareToEndAbility`里->`FirstTargetImplementsInterface`

如果为true->`MouseHitActor`->`Remove GameplayCue On Actor(Looping)`，`GameplayCueTag`选择`GameplayCue.ShockLoop`，`Parameters`用`FirstTargetCueParams`

如果为false->`GetAvatarActorFromActorInfo`->`Remove GameplayCue On Actor(Looping)`，`GameplayCueTag`选择`GameplayCue.ShockLoop`，`Parameters`用`FirstTargetCueParams`

![1712566977619](E:\Typora\TyporaPic\1712566977619.png)



### 在` GC_ShockLoop `里处理

`While Active`的时候把`SourceObject`给提升为变量

![1712567034212](E:\Typora\TyporaPic\1712567034212.png)

在`Set BeamSystem`后->`SourceObject`的`Does Implement Interface`选择`CombatInterface`

如果为true->`SourceObject`->`Cast To Actor`->`GetActorLocation`->`BeamSystem`的`SetNiagaraVariable(Vector3)`的`BeamEnd`，`InValue`用ActorLocation

如果为false->`BeamSystem`的`SetNiagaraVariable(Vector3)`的`BeamEnd`，`InValue`设置为`TargetLocation`

->`SpawnSoundAttached`

![1712567049599](E:\Typora\TyporaPic\1712567049599.png)

![1712567062097](E:\Typora\TyporaPic\1712567062097.png)

![1712567066094](E:\Typora\TyporaPic\1712567066094.png)





# Additional Targets

## 雷电射线的附加目标

### 在` AuraAbilitySystemLibrary `里处理

```cpp
public:
	UFUNCTION(BlueprintCallable, Category = "AuraAbilitySystemLibrary|GameplayMechanics")
	static void GetClosestTargets(int32 MaxTargets, const TArray<AActor*>& Actors, TArray<AActor*>& OutClosestTargets, const FVector& Origin);
```



```cpp
void UAuraAbilitySystemLibrary::GetClosestTargets(int32 MaxTargets, const TArray<AActor*>& Actors, TArray<AActor*>& OutClosestTargets, const FVector& Origin)
{
    if(Actors.Num() <= MaxTargets)
    {
        OutClosestTargets = Actors;
        return;
    }
    
    TArray<AActor*> ActorsToCheck = Actors;
    int32 NumTargetsFound = 0;
    while (NumTargetsFound < MaxTargets)
    {
        if(ActorsToCheck.Num() == 0)
        {
            break;
        }
        
        double ClosestDistance = TNumericLimits<double>::Max();
        AActor* ClosestActor;
        for(AActor* PotentialTarget : ActorsToCheck)
        {
            const double Distance = (PotentialTarget->GetActorLocation() - Origin).Length();
            if(Distance < ClosestDistance)
            {
                ClosestDistance = Distance;
                ClosestActor = PotentialTarget;
            }            
        }
        ActorsToCheck.Remove(ClosestActor);
        OutClosestTargets.AddUnique(ClosestActor);
        ++NumTargetsFound;
    }
}
```



### 在` AuraBeamSpell `里处理

之前处理敌人的近战攻击打到多少Actor的时候在`AuraAbilitySystemLibrary`里加过一个`GetLivePlayersWithinRadius`可以用

```cpp
public:
	UFUNCTION(BlueprintCallable)
	void StoreAdditionalTargets(TArray<AActor*>& OutAdditionalTargets);

protected:
	UPROPERTY(EditDefaultsOnly, Category = "Beam")
	int32 MaxNumShockTargets = 5;
```



```cpp
#include "AbilitySystem/AuraAbilitySystemLibrary.h"

void UAuraBeamSpell::StoreAdditionalTargets(TArray<AActor*>& OutAdditionalTargets)
{
    TArray<AActor*> OverlappingActors;
    TArray<AActor*> ActorsToIgnore;
	ActorsToIgnore.Add(GetAvatarActorFromActorInfo());
    ActorsToIgnore.Add(MouseHitActor);
    
    UAuraAbilitySystemLibrary::GetLivePlayersWithinRadius(
    	GetAvatarActorFromActorInfo(),
        OverlappingActors,
        ActorsToIgnore,
        850.0f,
        MouseHitActor->GetActorLocation()
    );
    
    int32 NumAdditionalTargets = FMath::Min(GetAbilityLevel() - 1, MaxNumShockTargets);
    
    UAuraAbilitySystemLibrary::GetClosestTargets(NumAdditionTargets, OverlappingActors, OutAdditionalTargets, MouseHitActor->GetActorLocation());
}
```



### 在` GA_Electrocute `里处理

`PrepareToEndAbility`的`Remove GameplayCue On Actor(Looping)`->`StoreAdditionalTargets`->`ForEachLoop`给`DrawDebugSphere`



![1712568394084](E:\Typora\TyporaPic\1712568394084.png)







# Shock Loop Cues on Additional Targets

## 给附加目标加上ShockLoopCue

### 在` GA_Electrocute `里处理

删掉`PrepareToEndAbility`的`StoreAdditionalTargets`



加个Variable命名为`AdditionalActorsToCueParams`，类型先设置为Actor然后在Details里把Variable Type设置为Map，Value选择`Gameplay Cue Parameters`

加个函数命名为`AddShockLoopCueToAdditionalTarget`，加个`AActor`类型的输入命名为`AdditionalTarget`->`Promote to local Variable`命名为`TargetActor`->`MakeGameplayCueParameters`，`SourceObject`设置为TargetActor，`Location`设置为TargetActor的GetActorLocation，`TargetAttachComponent`用`MouseHitActor`的`GetRootComponent`->`AdditionalActorsToCueParams`Add上->TargetActor的`AddGameplayCueOnActor(Looping)`，`GameplayCueTag`选择`GameplayCue.ShockLoop`，Params用`MakeGameplayCueParameters`的返回值

![1712570221529](E:\Typora\TyporaPic\1712570221529.png)



在`SpawnElectricBeam`里`AddGameplayCueOnActor(Looping)`之后，如果`FirstTargetImplementsInterface`为true->`StoreAdditionalTargets`把`StoreAdditionalTargets`的返回值`OutAdditionalTargets`给`Promote to Variable`命名为`AdditionalTargets`->`ForEachLoop`->`AddShockLoopCueToAdditionalTarget`

![1712570231864](E:\Typora\TyporaPic\1712570231864.png)



`PrepareToEndAbility`的`FirstTargetImplementsInterface`为true后->`AdditionalTargets`的ForEachLoop->

`AdditionalActorsToCueParams`的Find用`Array Element` 为true->`RemoveGameplayCueOnActor(Looping)`，`GameplayCueTag`选择`GameplayCue.ShockLoop`，`Parameters`用Map的Value，Target用`Array Element` ，包裹起来命名为`RemoveShockLoopCueFromAdditionalTarget`->ForEachLoop的OnCompleted->`MouseHitActor`的`RemoveGameplayCueOnActor(Looping)`，Parameters用`FirstTargetCueParams`

![1712570264884](E:\Typora\TyporaPic\1712570264884.png)



![1712576994591](E:\Typora\TyporaPic\1712576994591.png)





# Electrocute Cost Cooldown and Damage

## 雷电射线的消耗、冷却和伤害

### 在`ProjectSettings`里加个雷电射线的冷却Tag

` Cooldown.Lightning.Electrocute`



### 创建` GE_Cost_Electrocute`

放在` Content\Blueprints\AbilitySystem\Aura\Abilities\Lightning `下

`AuraAttributeSet.Mana`值填-1，Curve用` CT_Cost `的`Lightning.Electrocute`



### 创建` GE_Cooldown_Electrocute `

放在` Content\Blueprints\AbilitySystem\Aura\Abilities\Lightning `下

`Duration Policy`改成`Has Duration`，值填个1.0

`GrantedTags.Added`填` Cooldown.Lightning.Electrocute`	



### 在` CT_Cost `里处理

加个Curve命名为`Lightning.Electrocute`

```
1, 1
2, 1.5
3, 1.75
4, 2
5, 2.5
6, 3
7, 3.75
8, 4.5
9, 5.75
10, 7
```



### 在`CT_Damage`里处理

加个Curve命名为`Abilities.Electrocute`

```
1, 5
40, 20
```



### 在`GA_Electrocute`里处理

`Damage Effect Class`选择`GE_Damage`

`Damage Type`选择`Damage.Lightning`

`Damage`用`CT_Damage`的`Abilities.Electrocute`

`Debuff Chance`设为0，`Knockback Chance`设为0

`Instancing Policy`设置为`Instanced Per Actor`

`Cost Gameplay Effect Class`选择` GE_Cost_Electrocute `

`Cooldown Gameplay Effect Class`选择` GE_Cooldown_Electrocute `





# Applying Electrocute Cost and Damage

## 应用雷电射线的消耗和造成伤害

### 在` AuraDamageGameplayAbility `里处理

```cpp
public:
	UFUNCTION(BlueprintPure)
	float GetDamageAtLevel() const;
```



```cpp
float UAuraDamageGameplayAbility::GetDamageAtLevel() const
{
	return Damage.GetValueAtLevel(GetAbilityLevel());
}
```



### 在` GA_Electrocute`里处理

加个float类型的变量命名为`DamageDeltaTime`，默认值为0.1

加个bool类型的变量命名为`TargetDead`

加个新的函数命名为`ApplyDamageSingle`有个Actor类型的入参命名为`DamagedTarget`->`GetAbilitySystemComponentFromActorInfo`的`MakeEffectContext`->`Make Outgoing Spec`，Level用`GetAbilityLevel`，`GameplayEffectClass`用`DamageEffectClass`->`AssignTagSetByCallerMagnitude`选择`Damage.Lightning`，Damage用`GetDamageAtLevel`->`Actor`的`GetAbilitySystemComponent`的`ApplyGameplayEffectSpecToSelf`

![1712574129285](E:\Typora\TyporaPic\1712574129285.png)

![1712574133970](E:\Typora\TyporaPic\1712574133970.png)



加个新的函数命名为`ApplyDamage`->`MouseHitActor`的`ApplyDamageSingle`->`AdditionalTargets`的ForEachLoop->`ApplyDamageSingle`

![1712574147699](E:\Typora\TyporaPic\1712574147699.png)

在`Event Graph`里，`Spawn Electric Beam`->`Set Timer By Event`加个CustomEvent命名为`DamageAndCost`，`Time`用`DamageDeltaTime`，返回值Promote to Variable命名为`DamageAndCostTimer`

`DamageAndCost`->`Commit Ability Cost`

为true->`TargetDead`

​		为true->`DamageAndCostTimer`的`Clear and Invalidate Timer By Handle`->`ShowMouseCursor`->`Prepare to End Ability`->`End Ability`包裹起来命名为函数`ClearTimerAndEndAbility`

![1712574117026](E:\Typora\TyporaPic\1712574117026.png)

​		为false->`ApplyDamage`

为false->`ClearTimerAndEndAbility`

![1712574104695](E:\Typora\TyporaPic\1712574104695.png)





# Electrocute Polish

## 当受到攻击的敌方目标死亡时处理一下

主目标死亡，结束技能

附加目标死亡，结束对应的Cue

### 在` CombatInterface `里处理

自己之前写SpawnActor的时候有过一个一样功能的Delegate，挪一下

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FOnDeathSignature, AActor*, DeadActor);

public:
	virtual FOnDeathSignature& GetOnDeathDelegate() = 0;
```



### 在` AuraCharacterBase `里处理

```cpp
public:
	virtual FOnDeathSignature& GetOnDeathDelegate() override;

	FOnDeathSignature OnDeathDelegate;
```



```cpp
FOnDeathSignature& AAuraCharacterBase::GetOnDeathDelegate()
{
	return OnDeathDelegate;
}

void AAuraCharacterBase::MulticastHandleDeath_Implementation(const FVector& DeathImpulse)
{
    // ...
    OnDeathDelegate.Broadcast(this);
}
```



### 在` AuraBeamSpell `里处理

```cpp
public:
	UFUNCTION(BlueprintImplementableEvent)
	void PrimaryTargetDied(AActor* DeadActor);

	UFUNCTION(BlueprintImplementableEvent)
	void AdditionalTargetDied(AActor* DeadActor);
```



```cpp
void UAuraBeamSpell::TraceFirstTarget(const FVector& BeamTargetLocation)
{
	// ...
    if (ICombatInterface* CombatInterface = Cast<ICombatInterface>(MouseHitActor))
	{
		if (!CombatInterface->GetOnDeathDelegate().IsAlreadyBound(this, &UAuraBeamSpell::PrimaryTargetDied))
		{
			CombatInterface->GetOnDeathDelegate().AddDynamic(this, &UAuraBeamSpell::PrimaryTargetDied);
		}
	}
}

void UAuraBeamSpell::StoreAdditionalTargets(TArray<AActor*>& OutAdditionalTargets)
{
    // ...
    for (AActor* Target : OutAdditionalTargets)
	{
		if (ICombatInterface* CombatInterface = Cast<ICombatInterface>(Target))
		{
			if (!CombatInterface->GetOnDeathDelegate().IsAlreadyBound(this, &UAuraBeamSpell::AdditionalTargetDied))
			{
				CombatInterface->GetOnDeathDelegate().AddDynamic(this, &UAuraBeamSpell::AdditionalTargetDied);
			}
		}
	}
}
```



### 在` GA_Electrocute `里处理

`Event Primary Target Died`->`RemoveGameplayCueOnActor(Looping)`，`Parameters`用`FirstTargetCueParams`，`GameplayCueTag`选择`GameplayCue.ShockLoop`->`ClearTimerAndEndAbility`

![1712576409584](E:\Typora\TyporaPic\1712576369009.png)

`Event Additional Target Died`->`Remove ShockLoopCueFromAdditionalTarget`->`Additional Targets`的`Remove`

![1712576401287](E:\Typora\TyporaPic\1712576409584.png)



`DamageAndCost`里现在用不上`TargetDead`了，如果`CommitAbilityCost`为true直接`ApplyDamage`

![1712576356972](E:\Typora\TyporaPic\1712576356972.png)



在`ClearTimerAndEndAbility`里的`Prepare to End Ability`之后->`CommitAbilityCooldown`->`AdditionTargets`的Clear->`AdditionalActorsToCueParams`的Clear->`MouseHitActor`设置为null->`FirstTargetImplementsInterface`设置为false->`End Ability`

![1712576347709](E:\Typora\TyporaPic\1712576347709.png)



`Wait Input Release`后面换成`ClearTimerAndEndAbility`

![1712576335859](E:\Typora\TyporaPic\1712576335859.png)



## 应用一下技能冷却

除了释放完成开始进入冷却以外，还要有个最低释放时间，防止点击右键立刻又松开导致montage都没播放完就进冷却了

### 在`DA_AbilityInfo`里处理

雷电射线的`CooldownTag`选择`Cooldown.Lightning.Electrocute`



### 在` GA_Electrocute `里处理

加个float类型的变量命名为`MinSpellTime`默认值为0.5

`Wait Input Release`的`Time Held`给Promote to variable命名为`TimeHeld`->`TimeHeld`<`MinSpellTime`

如果为true则Delay，时间为`MinSpellTime`-`TimeHeld`然后再`ClearTimerAndEndAbility`

如果为false直接`ClearTimerAndEndAbility`

![1712577028064](E:\Typora\TyporaPic\1712577028064.png)



`ClearTimerAndEndAbility`里`TimeHeld`给set为0

![1712577016791](E:\Typora\TyporaPic\1712577016791.png)





# Explode Dem FireBoltz

## 修一下火球没爆炸的bug

当火球的飞行过程中Target死亡了就会出现这个问题

### 在` BP_FireBolt `里处理

`Tick Interval`设置为0.2

加两个Vector类型的变量分别命名为`LocationLastFrame`和`LocationThisFrame`

加个float类型的变量命名为`MinDistancePerFrame`，默认值为10.0

`Event Tick`->`LocationThisFrame`赋值给`LocationLastFrame`->`GetActorLocation`赋值给`LocationThisFrame`->`LocationThisFrame` - `LocationLastFrame`的`Vector Length`<`MinDistancePerFrame` 

为true->`Spawn Sound At Location`选择`sfx_FireBolt_Impact`，坐标用`LocationThisFrame`->`Spawn System At Location`选择`NS_FireExplosion`，坐标用`LocationThisFrame`->`Destroy Actor`

包裹起来命名为`MakeGoKaboomIfNoMove`



![1712577744326](E:\Typora\TyporaPic\1712577744326.png)



![1712577750313](E:\Typora\TyporaPic\1712577750313.png)







# Stun

## 修一下火球技能的释放会被雷电射线的抬手打断的问题

### 在`GA_FireBolt`里处理

`Block Abilities with Tag`填个`Abilities.Fire`和`Abilities.Lightning`



## 雷电射线有几率使敌人眩晕

### 在`GA_FireBolt`里处理

`Activation Blocked Tag`选择`Debuff.Stun`



### 在`GA_Electrocute`里处理

`DebuffChance`改成100

`DebuffDamage`改成0

`Knockback Force Magnitude`设置为0

`Activation Blocked Tag`选择`Debuff.Stun`

在`PrepareToEndAbility`里`FirstTargetImplementsInterface`为true的`RemoveGameplayCueOnActor(Looping)`->`MakeDamageEffectParamsfromClass`的TargetActor用`MouseHitActor`->`ApplyDamageEffect`->ForEachLoop的每个ArrayElement也都执行一次`MakeDamageEffectParamsfromClass`的TargetActor用`ArrayElement`->`ApplyDamageEffect`

![1712586001030](E:\Typora\TyporaPic\1712586001030.png)



### 在` AuraCharacterBase `里处理

加个`bIsStunned`，设置为网络复制变量

`StunTagChanged`可以参考`AAuraEnemy::HitReactTagChanged`，把`BaseWalkSpeed`从AuraEnemy挪回到基类里

```cpp
public:
	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const;

	UPROPERTY(ReplicatedUsing=OnRep_Stunned, BlueprintReadOnly)
	bool bIsStunned = false;

	UFUNCTION()
	virtual void OnRep_Stunned();

protected:
	virtual void StunTagChanged(const FGameplayTag CallbackTag, int32 NewCount);

	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Combat")
	float BaseWalkSpeed = 600.f;
```



```cpp
#include "GameFramework/CharacterMovementComponent.h"
#include "Net/UnrealNetwork.h"

void AAuraCharacterBase::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
	Super::GetLifetimeReplicatedProps(OutLifetimeProps);

	DOREPLIFETIME(AAuraCharacterBase, bIsStunned);
}

void AAuraCharacterBase::StunTagChanged(const FGameplayTag CallbackTag, int32 NewCount)
{
    bIsStunned = NewCount > 0;
	GetCharacterMovement()->MaxWalkSpeed = bIsStunned ? 0.f : BaseWalkSpeed;
}

void AAuraCharacterBase::OnRep_Stunned()
{
	
}
```



### 在`AuraCharacter`里处理

在ASC被创建后再`RegisterGameplayTagEvent`注册`Debuff_Stun`的添加或删除触发`StunTagChanged`

`OnRep_Stunned`负责在客户端执行当被施加了`Stun`的Debuff的GameplayTag的时候根据网络复制给客户端的`bIsStunned`来添加或者删除禁用玩家输入Tag

```cpp
public:
	virtual void OnRep_Stunned() override;
```



```cpp
#include "AuraGameplayTags.h"
#include "AbilitySystem/Debuff/DebuffNiagaraComponent.h"


void AAuraCharacter::InitAbilityActorInfo()
{
    // ...
    AbilitySystemComponent = AuraPlayerState->GetAbilitySystemComponent();
    AbilitySystemComponent->RegisterGameplayTagEvent(FAuraGameplayTags::Get().Debuff_Stun, EGameplayTagEventType::NewOrRemoved).AddUObject(this, &AAuraCharacter::StunTagChanged);
}

void AAuraCharacter::OnRep_Stunned()
{
    if (UAuraAbilitySystemComponent* AuraASC = Cast<UAuraAbilitySystemComponent>(AbilitySystemComponent))
	{
		const FAuraGameplayTags& GameplayTags = FAuraGameplayTags::Get();
		FGameplayTagContainer BlockedTags;
		BlockedTags.AddTag(GameplayTags.Player_Block_CursorTrace);
		BlockedTags.AddTag(GameplayTags.Player_Block_InputHeld);
		BlockedTags.AddTag(GameplayTags.Player_Block_InputPressed);
		BlockedTags.AddTag(GameplayTags.Player_Block_InputReleased);
		if (bIsStunned)
		{
			AuraASC->AddLooseGameplayTags(BlockedTags);
		}
		else
		{
			AuraASC->RemoveLooseGameplayTags(BlockedTags);
		}
	}
}
```



### 在` AuraEnemy `里处理

在构造函数里把挪到基类的`BaseWalkSpeed`设置一个Enemy的基准值

在ASC被创建后再`RegisterGameplayTagEvent`注册`Debuff_Stun`的添加或删除触发`StunTagChanged`

`StunTagChanged`可以参考`AAuraEnemy::HitReactTagChanged`，把Blackboard里的Stunned设置Value

```cpp
protected:
	virtual void StunTagChanged(const FGameplayTag CallbackTag, int32 NewCount) override;
```



```cpp
AAuraEnemy::AAuraEnemy()
{
    // ...
    BaseWalkSpeed = 250.f;
}

void AAuraEnemy::InitAbilityActorInfo()
{
    // ...
    AbilitySystemComponent->RegisterGameplayTagEvent(FAuraGameplayTags::Get().Debuff_Stun, EGameplayTagEventType::NewOrRemoved).AddUObject(this, &AAuraEnemy::StunTagChanged);
}

void AAuraEnemy::StunTagChanged(const FGameplayTag CallbackTag, int32 NewCount)
{
    Super::StunTagChanged(CallbackTag, NewCount);
    
    if (AuraAIController && AuraAIController->GetBlackboardComponent())
	{
		AuraAIController->GetBlackboardComponent()->SetValueAsBool(FName("Stunned"), bIsStunned);
	}
}
```



### 在` AuraAttributeSet `里处理

如果加的Debuff是Stun，就把禁用玩家输入的Tag都加到`InheritableOwnedTagsContainer`上

```cpp
void UAuraAttributeSet::Debuff(const FEffectProperties& Props)
{
    // ...
    UGameplayEffect* Effect = NewObject<UGameplayEffect>(GetTransientPackage(), FName(DebuffName));
    
    const FGameplayTag DebuffTag = GameplayTags.DamageTypesToDebuffs[DamageType];
	Effect->InheritableOwnedTagsContainer.AddTag(DebuffTag);
    
	if (DebuffTag.MatchesTagExact(GameplayTags.Debuff_Stun))
	{
		Effect->InheritableOwnedTagsContainer.AddTag(GameplayTags.Player_Block_CursorTrace);
		Effect->InheritableOwnedTagsContainer.AddTag(GameplayTags.Player_Block_InputHeld);
		Effect->InheritableOwnedTagsContainer.AddTag(GameplayTags.Player_Block_InputPressed);
		Effect->InheritableOwnedTagsContainer.AddTag(GameplayTags.Player_Block_InputReleased);
	}
    
    // ...
}
```





### 创建` HitReact_Spear_cut`

放在` Content\Assets\Enemies\Goblin\Animations\Spear `下

复制一份`HitReact_Spear`

在第27帧右击选择`Remove from frame 28 to frame 42`

选中`EnableRootMotion`



### 在` AM_HitReact_GoblinSpear `里处理

把` HitReact_Spear_cut `替换掉` HitReact_Spear`



### 在`ABP_Enemy`里处理

`Cast To AuraEnemy`之后给Promote to Variable命名为`AuraEnemy`

`Event Blueprint Update Animation`加个Sequence

`AuraEnemy`右击选择`Convert to Validated Get`为Valid->`GetIsStunned`->Promote to Variable命名为`Stunned`

![1712586102504](E:\Typora\TyporaPic\1712586102504.png)

转到`MainStates`

添加一个State命名为`Stunned`，和IdleWalkRun之间的状态切换根据`Stunned`

`Stunned`里`Sequence Player`->`Output Animation Pose`

IdleWalkRun->Stunned的`Duration`改成0.4



### 在`ABP_Goblin_Slingshot`里处理

`Stunned`里的`Sequence Player`选择`Slingshot_Stun_Loop`



### 在` ABP_Goblin_Spear `里处理

`Stunned`里的`Sequence Player`选择`Stun_Loop`



### 在` ABP_Shaman `里处理

`Stunned`里的`Sequence Player`选择`Shaman_Stun`



### 在`  ABP_Ghoul`里处理

`Stunned`里的`Sequence Player`选择`Stun`



### 在`  ABP_Demon`里处理

`Stunned`里的`Sequence Player`选择`Demon_Stun`



### 在`ABP_Aura`里处理

`Event Blueprint Update Animation`加个Sequence

`BPAuraCharacter`右击选择`Convert to Validated Get`为Valid->`GetIsStunned`->Promote to Variable命名为`Stunned`

转到`MainStates`

把Stun从`Asset Browser`拖进来添加一个State命名为`Stun`，进入State后把`Loop Animation`设置为true，状态切换根据`Stunned`

`Add State Alias`选择Running,Idle,InAir,Cast_Shock_Loop

![1712586402627](E:\Typora\TyporaPic\1712586402627.png)



### 在` BB_EnemyBlackboard `里处理

加个bool类型的Key命名为Stunned



### 在` BT_EnemyBehaviorTree `里处理

```
在和`Am I Not Hit Reacting`同一个Selector节点右击选择Add Decorator选择Blackboard重命名为`Am I Not Stunned?`，`Notify Observer`选择`On Value Change`，`Observer aborts`选择`Self`，`Key Query`选择`Is Not Set`，`Blackboard Key`选择`Stunned`
```



### 在` BT_EnemyBehaviorTree_Elementalist `里处理

```
在和`Am I Not Hit Reacting`同一个Selector节点右击选择Add Decorator选择Blackboard重命名为`Am I Not Stunned?`，`Notify Observer`选择`On Value Change`，`Observer aborts`选择`Self`，`Key Query`选择`Is Not Set`，`Blackboard Key`选择`Stunned`
```





# Stun Niagara System

## 修一下客户端表现的问题

### 在`GA_Electrocute`里处理

`Wait Input Release`的Branch为true的时候->`HasAuthority`为true才Delay，false的话则执行`Prepare to End Ability`

![1712636377271](E:\Typora\TyporaPic\1712636377271.png)

`Prepare to End Ability`里`Apply Damage Effect`之前也要`HasAuthority`

![1712636360797](E:\Typora\TyporaPic\1712636360797.png)



### 在` AuraProjectile `里处理

```cpp
void AAuraProjectile::BeginPlay()
{
    // ...
    SetReplicateMovement(true);
}

void AAuraProjectile::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	if (!DamageEffectParams.SourceAbilitySystemComponent)
    {
        return;
    }
    
    // ...
}
```



### 在`BP_FireBolt`里处理

`Replicate Movement`确保已勾选



## 给眩晕加个粒子特效

### 在` CombatInterface `里处理

`UDebuffNiagaraComponent`里用的时候返回引用而不是值

```cpp
public:
	virtual FOnASCRegistered& GetOnASCRegisteredDelegate() = 0;
```



### 在` AuraCharacterBase `里处理

加个新的`UDebuffNiagaraComponent`处理Stun的特效

加个bool类型的可网络复制的`bIsBurned`用于在客户端同步烧伤特效的开关

```cpp
public:
	virtual FOnASCRegistered& GetOnASCRegisteredDelegate() override;

	UPROPERTY(ReplicatedUsing=OnRep_Burned, BlueprintReadOnly)
	bool bIsBurned = false;

	UFUNCTION()
	virtual void OnRep_Burned();

protected:
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UDebuffNiagaraComponent> StunDebuffComponent;
```



```cpp
AAuraCharacterBase::AAuraCharacterBase()
{
    // ...
    StunDebuffComponent = CreateDefaultSubobject<UDebuffNiagaraComponent>("StunDebuffComponent");
	StunDebuffComponent->SetupAttachment(GetRootComponent());
	StunDebuffComponent->DebuffTag = GameplayTags.Debuff_Stun;
}

void AAuraCharacterBase::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    // ...
    DOREPLIFETIME(AAuraCharacterBase, bIsBurned);
}

void AAuraCharacterBase::MulticastHandleDeath_Implementation(const FVector& DeathImpulse)
{
    // ...
    StunDebuffComponent->Deactivate();
}

FOnASCRegistered& AAuraCharacterBase::GetOnASCRegisteredDelegate()
{
	return OnAscRegistered;
}

void AAuraCharacterBase::OnRep_Burned()
{
    
}
```



### 在`AuraCharacter`里处理

```cpp
public:
	virtual void OnRep_Burned() override;
```



```cpp
void AAuraCharacter::OnRep_Stunned()
{
	// ...
    if (bIsStunned)
    {
        AuraASC->AddLooseGameplayTags(BlockedTags);
        StunDebuffComponent->Activate();
    }
    else
    {
        AuraASC->RemoveLooseGameplayTags(BlockedTags);
        StunDebuffComponent->Deactivate();
    }
}

void AAuraCharacter::OnRep_Burned()
{
	if (bIsBurned)
	{
		BurnDebuffComponent->Activate();
	}
	else
	{
		BurnDebuffComponent->Deactivate();
	}
}
```



### 在`BP_EnemyBase`里处理

`StunDebuffComponent`里`NiagaraSystemAsset`用`NS_Stars`

`StunDebuffComponent`的Location调整为(0,0,45)



### 在`  BP_Ghoul`里处理

`StunDebuffComponent`的Location调整为(70,0,65)



### 在`  BP_Demon_Ranger`里处理

`StunDebuffComponent`的Location调整为(0,0,25)



### 在` BP_Demon_Warrior `里处理

`StunDebuffComponent`的Location调整为(0,0,25)



### 在`BP_AuraCharacter`里处理

`StunDebuffComponent`里`NiagaraSystemAsset`用`NS_Stars`

`StunDebuffComponent`的Location调整为(0,0,70)





# Shock Loop Animations

## 被射线持续攻击的时候不播放HitReact而是单独的动画

### 在` CombatInterface `里处理

```cpp
public:
	UFUNCTION(BlueprintNativeEvent, BlueprintCallable)
	bool IsBeingShocked() const;

	UFUNCTION(BlueprintNativeEvent, BlueprintCallable)
	void SetIsBeingShocked(bool bInShock);
```



### 在` AuraCharacterBase `里处理

```cpp
public:
	virtual void SetIsBeingShocked_Implementation(bool bInShock) override;
	virtual bool IsBeingShocked_Implementation() const override;

	UPROPERTY(Replicated, BlueprintReadOnly)
	bool bIsBeingShocked = false;
```



```cpp
void AAuraCharacterBase::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const
{
    // ...
    DOREPLIFETIME(AAuraCharacterBase, bIsBeingShocked);
}

void AAuraCharacterBase::SetIsBeingShocked_Implementation(bool bInShock)
{
	bIsBeingShocked = bInShock;
}

bool AAuraCharacterBase::IsBeingShocked_Implementation() const
{
	return bIsBeingShocked;
}
```



### 在` AuraAttributeSet `里处理

如果没被射线击中进入ShockLoop状态，才把HitReact加到ASC上

```cpp
void UAuraAttributeSet::HandleIncomingDamage(const FEffectProperties& Props)
{
    // ...
    if (bFatal)
    {
        // ...
    }
    else
    {
        if (Props.TargetCharacter->Implements<UCombatInterface>() && !ICombatInterface::Execute_IsBeingShocked(Props.TargetCharacter))
        {
            FGameplayTagContainer TagContainer;
            TagContainer.AddTag(FAuraGameplayTags::Get().Effects_HitReact);
            Props.TargetASC->TryActivateAbilitiesByTag(TagContainer);
        }
        // ...
    }
}
```



### 在`GA_Electrocute`里处理

`SpawnElectricBeam`里的`FirstTargetImplementsInterface`为true->`CueTarget`的`SetIsBeingShocked`为true->...->ForEachLoop->->`SetIsBeingShocked`为true->`Add ShockLoop Cue to Additional Target`

![1712637553051](E:\Typora\TyporaPic\1712637553051.png)



`PrepareToEndAbility`的`FirstTargetImplementsInterface`为true->`MouseHitActor`的`SetIsBeingShocked`为false->...->ForEachLoop->`SetIsBeingShocked`为false

![1712637614718](E:\Typora\TyporaPic\1712637614718.png)



### 在`ABP_Enemy`里处理

Sequence的最后->`AuraEnemy`右击选择`Convert to Validated Get`为Valid->`IsBeingShocked`->Promote to Variable命名为`IsBeingShocked`

![1712637687972](E:\Typora\TyporaPic\1712637687972.png)



`Main States`里加个新的State命名为`BeingShocked`，进入其中加个`SequencePlayer`，和IdleWalkRun之间的转换用`IsBeingShocked`



### 在`ABP_Goblin_Slingshot`里处理

`Stunned`里的`Sequence Player`选择`ShockLoop`



### 在` ABP_Goblin_Spear `里处理

`Stunned`里的`Sequence Player`选择`ShockLoop`



### 在` ABP_Shaman `里处理

`Stunned`里的`Sequence Player`选择`Shaman_ShockLoop`



### 在`  ABP_Ghoul`里处理

`Stunned`里的`Sequence Player`选择`ShockLoop`



### 在`  ABP_Demon`里处理

`Stunned`里的`Sequence Player`选择`DemonShockLoop`































