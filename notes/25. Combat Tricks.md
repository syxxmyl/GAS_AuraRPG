# Debuff Tags

## 加些Debuff的Tag

### 在`AuraGameplayTag`里处理

类似Resistance，加个Map存一下每种伤害类型能触发的Debuff

```cpp
public:
	FGameplayTag Debuff_Burn;
	FGameplayTag Debuff_Stun;
	FGameplayTag Debuff_Arcane;
	FGameplayTag Debuff_Physical;

	TMap<FGameplayTag, FGameplayTag> DamageTypesToDebuffs;
```



```cpp
void FAuraGameplayTags::InitializeNativeGameplayTags()
{
    // ...
    /*
	 * Debuffs
	 */

	GameplayTags.Debuff_Arcane = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Debuff.Arcane"),
		FString("Debuff for Arcane damage")
	);
    
	GameplayTags.Debuff_Burn = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Debuff.Burn"),
		FString("Debuff for Fire damage")
	);
    
	GameplayTags.Debuff_Physical = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Debuff.Physical"),
		FString("Debuff for Physical damage")
	);
    
	GameplayTags.Debuff_Stun = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Debuff.Stun"),
		FString("Debuff for Lightning damage")
	);
    
    /*
	 * Map of Damage Types to Debuffs
	 */
	GameplayTags.DamageTypesToDebuffs.Add(GameplayTags.Damage_Arcane, GameplayTags.Debuff_Arcane);
	GameplayTags.DamageTypesToDebuffs.Add(GameplayTags.Damage_Lightning, GameplayTags.Debuff_Stun);
	GameplayTags.DamageTypesToDebuffs.Add(GameplayTags.Damage_Physical, GameplayTags.Debuff_Physical);
	GameplayTags.DamageTypesToDebuffs.Add(GameplayTags.Damage_Fire, GameplayTags.Debuff_Burn);
}
```



### 在` AuraDamageGameplayAbility`里处理

改一下，每种Ability只会造成一种类型的伤害，方便处理debuff，后面要有一个技能触发多种debuff的到时候再加新类单独处理

```cpp
protected:
	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	FGameplayTag DamageType;

	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	FScalableFloat Damage;
```



```cpp
void UAuraDamageGameplayAbility::CauseDamage(AActor* TargetActor)
{
	// ...
    const float ScaledDamage = Damage.GetValueAtLevel(GetAbilityLevel());
	UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(DamageSpecHandle, DamageType, ScaledDamage);
    // ...
}
```



### 在` AuraFireBolt`里处理

描述里获取的Damage改一下

```cpp
FString UAuraFireBolt::GetDescription(int32 Level)
FString UAuraFireBolt::GetNextLevelDescription(int32 Level)
{
	// ...
    const int32 ScaledDamage = Damage.GetValueAtLevel(Level);
}
```



### 在` AuraProjectileSpell`里处理

```cpp
void UAuraProjectileSpell::SpawnProjectile(const FVector& ProjectileTargetLocation, const FGameplayTag& SocketTag, bool bOverridePitch, float PitchOverride)
{
	// ...
    const float ScaledDamage = Damage.GetValueAtLevel(GetAbilityLevel());
	UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpecHandle, DamageType, ScaledDamage);
}
```



### 在` GA_FireBolt`里处理

`Damage Type`改成`Damage.Fire`

`Damage`填1，选择`CT_Damage.Abilities.FireBolt`



### 在` GA_EnemyFireBolt`里处理

`Damage Type`改成`Damage.Fire`

`Damage`填1，选择`CT_Damage.Abilities.FireBolt`



### 在` GA_MeleeAttack`里处理

`Damage Type`改成`Damage.Physical`

`Damage`填1，选择`CT_Damage.Abilities.Melee`



### 在` GA_RangedAttack`里处理

`Damage Type`改成`Damage.Physical`

`Damage`填1，选择`CT_Damage.Abilities.Ranged`





# Debuff Parameters

## Debuff的参数

### 在` AuraGameplayTags`里处理

给Debuff的参数都加个Tag，后面`AssignTagSetByCallerMagnitude`的时候可以借助Tag传递这些值

```cpp
public:
	FGameplayTag Debuff_Chance;
	FGameplayTag Debuff_Damage;
	FGameplayTag Debuff_Duration;
	FGameplayTag Debuff_Frequency;
```



```cpp
void FAuraGameplayTags::InitializeNativeGameplayTags()
{
    // ...
    GameplayTags.Debuff_Chance = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Debuff.Chance"),
		FString("Debuff Chance")
	);
    
	GameplayTags.Debuff_Damage = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Debuff.Damage"),
		FString("Debuff Damage")
	);
    
	GameplayTags.Debuff_Duration = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Debuff.Duration"),
		FString("Debuff Duration")
	);
    
	GameplayTags.Debuff_Frequency = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Debuff.Frequency"),
		FString("Debuff Frequency")
	);
}
```



### 在` AuraDamageGameplayAbility`里处理

```cpp
protected:
	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	float DebuffChance = 20.f;

	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	float DebuffDamage = 5.f;

	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	float DebuffFrequency = 1.f;

	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	float DebuffDuration = 5.f;
```





# Damage Effect Params Struct

## 伤害effect的参数结构体

### 在` AuraAbilityTypes`里处理

```cpp
USTRUCT(BlueprintType)
struct FDamageEffectParams
{
	GENERATED_BODY()

	FDamageEffectParams(){}

	UPROPERTY()
	TObjectPtr<UObject> WorldContextObject = nullptr;

	UPROPERTY()
	TSubclassOf<UGameplayEffect> DamageGameplayEffectClass = nullptr;

	UPROPERTY()
	TObjectPtr<UAbilitySystemComponent> SourceAbilitySystemComponent;

	UPROPERTY()
	TObjectPtr<UAbilitySystemComponent> TargetAbilitySystemComponent;

	UPROPERTY()
	float BaseDamage = 0.f;

	UPROPERTY()
	float AbilityLevel = 1.f;

	UPROPERTY()
	FGameplayTag DamageType = FGameplayTag();

	UPROPERTY()
	float DebuffChance = 0.f;

	UPROPERTY()
	float DebuffDamage = 0.f;

	UPROPERTY()
	float DebuffDuration = 0.f;

	UPROPERTY()
	float DebuffFrequency = 0.f;
};
```



### 在` AuraDamageGameplayAbility`里处理

加个函数构造一下结构体

```cpp
#include "AuraAbilityTypes.h"

public:
	FDamageEffectParams MakeDamageEffectParamsFromClassDefaults(AActor* TargetActor = nullptr) const;
```



```cpp
FDamageEffectParams UAuraDamageGameplayAbility::MakeDamageEffectParamsFromClassDefaults(AActor* TargetActor) const
{
    FDamageEffectParams Params;
    
    Params.WorldContextObject = GetAvatarActorFromActorInfo();
    Params.DamageGameplayEffectClass = DamageEffectClass;
    Params.SourceAbilitySystemComponent = GetAbilitySystemComponentFromActorInfo();
    Params.TargetAbilitySystemComponent = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(TargetActor);
    Params.BaseDamage = Damage.GetValueAtLevel(GetAbilityLevel());
    Params.AbilityLevel = GetAbilityLevel();
    Params.DamageType = DamageType;
	Params.DebuffChance = DebuffChance;
	Params.DebuffDamage = DebuffDamage;
	Params.DebuffDuration = DebuffDuration;
	Params.DebuffFrequency = DebuffFrequency;
    
    return Params;
}
```



### 在` AuraAbilitySystemLibrary`里处理

加个函数把`DamageEffectParams`代表的DebuffEffect传递给Target，返回值返回一下EffectContextHandle，之后可能用得上获取其他上下文的内容

```cpp
public:
	UFUNCTION(BlueprintCallable, Category = "AuraAbilitySystemLibrary|DamageEffect")
	static FGameplayEffectContextHandle ApplyDamageEffect(const FDamageEffectParams& DamageEffectParams);
```



```cpp
#include "AbilitySystemBlueprintLibrary.h"
#include "AuraGameplayTags.h"

FGameplayEffectContextHandle UAuraAbilitySystemLibrary::ApplyDamageEffect(const FDamageEffectParams& DamageEffectParams)
{
    FGameplayEffectContextHandle EffectContextHandle = DamageEffectParams.SourceAbilitySystemComponent->MakeEffectContext();
    const AActor* SourceAvatarActor = DamageEffectParams.SourceAbilitySystemComponent->GetAvatarActor();
    EffectContextHandle.AddSourceObject(SourceAvatarActor);
    FGameplayEffectSpecHandle SpecHandle = DamageEffectParams.SourceAbilitySystemComponent->MakeOutgoingSpec(DamageEffectParams.DamageGameplayEffectClass, DamageEffectParams.AbilityLevel, EffectContextHandle);
    const FAuraGameplayTags GameplayTags = FAuraGameplayTags::Get();
    UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpecHandle, DamageEffectParams.DamageType, DamageEffectParams.BaseDamage);
	UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpecHandle, GameplayTags.Debuff_Chance, DamageEffectParams.DebuffChance);
	UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpecHandle, GameplayTags.Debuff_Damage, DamageEffectParams.DebuffDamage);
	UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpecHandle, GameplayTags.Debuff_Duration, DamageEffectParams.DebuffDuration);
	UAbilitySystemBlueprintLibrary::AssignTagSetByCallerMagnitude(SpecHandle, GameplayTags.Debuff_Frequency, DamageEffectParams.DebuffFrequency);
    
    DamageEffectParams.TargetAbilitySystemComponent->ApplyGameplayEffectSpecToSelf(*SpecHandle.Data.Get());
    
    return EffectContextHandle;
}
```





# Using Damage Effect Params

## 使用DamageEffect的Params

### 在` AuraProjectile`里处理

` DamageEffectSpecHandle `换成` DamageEffectParams `

修改一下Overlap后的处理方式，给Target添加GameplayEffect改成调用前面新加的函数库里的`ApplyDamageEffect`

加个函数`OnHit`用来执行播放特效之类的内容

```cpp
#include "AuraAbilityTypes.h"

public:
	UPROPERTY(BlueprintReadWrite, meta = (ExposeOnSpawn = true))
	FDamageEffectParams DamageEffectParams;

protected:
	void OnHit();
```



```cpp
void AAuraProjectile::OnHit()
{
    UGameplayStatics::PlaySoundAtLocation(this, ImpactSound, GetActorLocation(), FRotator::ZeroRotator);
    UNiagaraFunctionLibrary::SpawnSystemAtLocation(this, ImpactEffect, GetActorLocation());
    if (LoopingSoundComponent)
    {
        LoopingSoundComponent->Stop();
    }
    bHit = true;
}

void AAuraProjectile::Destroyed()
{
    if (!bHit && !HasAuthority())
    {
        OnHit();
    }
    
    Super::Destroyed();
}

void AAuraProjectile::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
    AActor* SourceAvatarActor = DamageEffectParams.SourceAbilitySystemComponent->GetAvatarActor();
    if(SourceAvatarActor == OtherActor)
    {
        return;
    }
    
    if (!UAuraAbilitySystemLibrary::IsNotFriend(SourceAvatarActor, OtherActor))
    {
        return;
    }
    
    if (!bHit)
    {
        OnHit();
    }
    
    if (HasAuthority())
    {
        if (UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OtherActor))
        {
            DamageEffectParams.TargetAbilitySystemComponent = TargetASC;
            UAuraAbilitySystemLibrary::ApplyDamageEffect(DamageEffectParams);
        }
        
        Destroy();
    }
    else
    {
        bHit = true;
    }
}
```



### 在` AuraProjectileSpell`里处理

原本给Spawn的Projectile设置GameplayEffect的上下文各种数据的代码改成调` MakeDamageEffectParamsFromClassDefaults()`



```cpp
void UAuraProjectileSpell::SpawnProjectile(const FVector& ProjectileTargetLocation, const FGameplayTag& SocketTag, bool bOverridePitch, float PitchOverride)
{
    // ...
    Projectile->DamageEffectParams = MakeDamageEffectParamsFromClassDefaults();
    Projectile->FinishSpawning(SpawnTransform);
}
```





# Determining Debuff

## 处理Debuff

### 在` ExecCalc_Damage`里处理

把`AuraDamageStatics`里的`TagsToCaptureDefs`挪到` Execute_Implementation`里，改成每次调用的时候塞个map

根据存在AuraGameplayTags里的map映射关系拿到context里塞的对应的debuff，和对应属性的抗性计算完后roll一下看看是否触发debuff

```cpp
public:
	void DetermineDebuff(const FGameplayEffectCustomExecutionParameters& ExecutionParams, const FGameplayEffectSpec& Spec, FAggregatorEvaluateParameters EvaluationParameters, const TMap<FGameplayTag, FGameplayEffectAttributeCaptureDefinition>& InTagsToDefs) const;
```



```cpp
void UExecCalc_Damage::Execute_Implementation(const FGameplayEffectCustomExecutionParameters& ExecutionParams, FGameplayEffectCustomExecutionOutput& OutExecutionOutput) const
{
    TMap<FGameplayTag, FGameplayEffectAttributeCaptureDefinition> TagsToCaptureDefs;
	const FAuraGameplayTags& Tags = FAuraGameplayTags::Get();
		
	TagsToCaptureDefs.Add(Tags.Attributes_Secondary_Armor, DamageStatics().ArmorDef);
	TagsToCaptureDefs.Add(Tags.Attributes_Secondary_BlockChance, DamageStatics().BlockChanceDef);
	TagsToCaptureDefs.Add(Tags.Attributes_Secondary_ArmorPenetration, DamageStatics().ArmorPenetrationDef);
	TagsToCaptureDefs.Add(Tags.Attributes_Secondary_CriticalHitChance, DamageStatics().CriticalHitChanceDef);
	TagsToCaptureDefs.Add(Tags.Attributes_Secondary_CriticalHitResistance, DamageStatics().CriticalHitResistanceDef);
	TagsToCaptureDefs.Add(Tags.Attributes_Secondary_CriticalHitDamage, DamageStatics().CriticalHitDamageDef);

	TagsToCaptureDefs.Add(Tags.Attributes_Resistance_Arcane, DamageStatics().ArcaneResistanceDef);
	TagsToCaptureDefs.Add(Tags.Attributes_Resistance_Fire, DamageStatics().FireResistanceDef);
	TagsToCaptureDefs.Add(Tags.Attributes_Resistance_Lightning, DamageStatics().LightningResistanceDef);
	TagsToCaptureDefs.Add(Tags.Attributes_Resistance_Physical, DamageStatics().PhysicalResistanceDef);
    // ...
    
    DetermineDebuff(ExecutionParams, Spec, EvaluationParameters, TagsToCaptureDefs);
    
    float Damage = 0.f;
    // ...
    const FGameplayTag DamageTypeTag = Pair.Key;
	const FGameplayTag ResistanceTypeTag = Pair.Value;
	checkf(TagsToCaptureDefs.Contains(ResistanceTypeTag), TEXT("TagsToCaptureDefs doesn't contain Tag: [%s] in ExecCalc_Damage"), *ResistanceTypeTag.ToString());
	const FGameplayEffectAttributeCaptureDefinition CaptureDef = TagsToCaptureDefs[ResistanceTypeTag];
}
    
void UExecCalc_Damage::DetermineDebuff(const FGameplayEffectCustomExecutionParameters& ExecutionParams, const FGameplayEffectSpec& Spec, FAggregatorEvaluateParameters EvaluationParameters, const TMap<FGameplayTag, FGameplayEffectAttributeCaptureDefinition>& InTagsToDefs) const
{
	const FAuraGameplayTags& GameplayTags = FAuraGameplayTags::Get();

	for (TTuple<FGameplayTag, FGameplayTag> Pair : GameplayTags.DamageTypesToDebuffs)
    {
        const FGameplayTag& DamageType = Pair.Key;
        const FGameplayTag& DebuffType = Pair.Value;
        const float TypeDamage = Spec.GetSetByCallerMagnitude(DamageType, false, -1);
        if(TypeDamage > 0.0f)
        {
            const float SourceDebuffChance = Spec.GetSetByCallerMagnitude(GameplayTags.Debuff_Chance, false, -1.f);
            const FGameplayTag& ResistanceTag = GameplayTags.DamageTypesToResistances[DamageType];
            float TargetDebuffResistance = 0.0f;
            ExecutionParams.AttemptCalculateCapturedAttributeMagnitude(InTagsToDefs[ResistanceTag], EvaluationParameters, TargetDebuffResistance);
            TargetDebuffResistance = FMath::Max<float>(TargetDebuffResistance, 0.f);
            const float EffectiveDebuffChance = SourceDebuffChance * ( 100 - TargetDebuffResistance ) / 100.f;
            const bool bDebuff = FMath::RandRange(1, 100) < EffectiveDebuffChance;
			if (bDebuff)
            {
                
            }
        }
    }
}
```





# Debuff Info in the Effect Context

## 把debuff的相关数据塞到GameplayEffect的Context里

### 在` AuraAbilityTypes`里处理

其他几个都是float直接序列化即可，DamageType是个FGameplayTag，要调用结构体自己的NetSerialize

```cpp
public:
	bool IsSuccessfulDebuff() const { return bIsSuccessfulDebuff; }
	float GetDebuffDamage() const { return DebuffDamage; }
	float GetDebuffDuration() const { return DebuffDuration; }
	float GetDebuffFrequency() const { return DebuffFrequency; }
	TSharedPtr<FGameplayTag> GetDamageType() const { return DamageType; }

	void SetIsSuccessfulDebuff(bool bInIsDebuff) { bIsSuccessfulDebuff = bInIsDebuff; }
	void SetDebuffDamage(float InDamage) { DebuffDamage = InDamage; }
	void SetDebuffDuration(float InDuration) { DebuffDuration = InDuration; }
	void SetDebuffFrequency(float InFrequency) { DebuffFrequency = InFrequency; }
	void SetDamageType(TSharedPtr<FGameplayTag> InDamageType) { DamageType = InDamageType; }

protected:
	UPROPERTY()
	bool bIsSuccessfulDebuff = false;

	UPROPERTY()
	float DebuffDamage = 0.f;

	UPROPERTY()
	float DebuffDuration = 0.f;

	UPROPERTY()
	float DebuffFrequency = 0.f;

	TSharedPtr<FGameplayTag> DamageType;
```



```cpp
bool FAuraGameplayEffectContext::NetSerialize(FArchive& Ar, UPackageMap* Map, bool& bOutSuccess)
{
    if (Ar.IsSaving())
    {
        // ...
        if (bIsSuccessfulDebuff)
		{
			RepBits |= 1 << 9;
		}
		if (DebuffDamage > 0.f)
		{
			RepBits |= 1 << 10;
		}
		if (DebuffDuration > 0.f)
		{
			RepBits |= 1 << 11;
		}
		if (DebuffFrequency > 0.f)
		{
			RepBits |= 1 << 12;
		}
		if (DamageType.IsValid())
		{
			RepBits |= 1 << 13;
		}
    }
    
    Ar.SerializeBits(&RepBits, 13);
    
    // ...
    if (RepBits & (1 << 9))
	{
		Ar << bIsSuccessfulDebuff;
	}
	if (RepBits & (1 << 10))
	{
		Ar << DebuffDamage;
	}
	if (RepBits & (1 << 11))
	{
		Ar << DebuffDuration;
	}
	if (RepBits & (1 << 12))
	{
		Ar << DebuffFrequency;
	}
	if (RepBits & (1 << 13))
	{
		if (Ar.IsLoading())
		{
			if (!DamageType.IsValid())
			{
				DamageType = TSharedPtr<FGameplayTag>(new FGameplayTag());
			}
		}
		DamageType->NetSerialize(Ar, Map, bOutSuccess);
    }
}
```



### 在` AuraAbilitySystemLibrary`里处理

加几个函数从上下文里获取和设置到Debuff的Infos

`GetDamageType`注意检查一下DamageType是否是`IsValid`的

`SetDamageType`的时候用`MakeShared`构造然后塞进去

```cpp
public:
	UFUNCTION(BlueprintPure, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static bool IsSuccessfulDebuff(const FGameplayEffectContextHandle& EffectContextHandle);

	UFUNCTION(BlueprintPure, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static float GetDebuffDamage(const FGameplayEffectContextHandle& EffectContextHandle);

	UFUNCTION(BlueprintPure, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static float GetDebuffDuration(const FGameplayEffectContextHandle& EffectContextHandle);

	UFUNCTION(BlueprintPure, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static float GetDebuffFrequency(const FGameplayEffectContextHandle& EffectContextHandle);

	UFUNCTION(BlueprintPure, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static FGameplayTag GetDamageType(const FGameplayEffectContextHandle& EffectContextHandle);

	UFUNCTION(BlueprintCallable, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static void SetIsSuccessfulDebuff(UPARAM(ref) FGameplayEffectContextHandle& EffectContextHandle, bool bInSuccessfulDebuff);

	UFUNCTION(BlueprintCallable, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static void SetDebuffDamage(UPARAM(ref) FGameplayEffectContextHandle& EffectContextHandle, float InDamage);

	UFUNCTION(BlueprintCallable, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static void SetDebuffDuration(UPARAM(ref) FGameplayEffectContextHandle& EffectContextHandle, float InDuration);

	UFUNCTION(BlueprintCallable, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static void SetDebuffFrequency(UPARAM(ref) FGameplayEffectContextHandle& EffectContextHandle, float InFrequency);

	UFUNCTION(BlueprintCallable, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static void SetDamageType(UPARAM(ref) FGameplayEffectContextHandle& EffectContextHandle, const FGameplayTag& InDamageType);
```



```cpp
bool UAuraAbilitySystemLibrary::IsSuccessfulDebuff(const FGameplayEffectContextHandle& EffectContextHandle)
{
	if (const FAuraGameplayEffectContext* AuraEffectContext = static_cast<const FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		return AuraEffectContext->IsSuccessfulDebuff();
	}
	return false;
}

float UAuraAbilitySystemLibrary::GetDebuffDamage(const FGameplayEffectContextHandle& EffectContextHandle)
{
	if (const FAuraGameplayEffectContext* AuraEffectContext = static_cast<const FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		return AuraEffectContext->GetDebuffDamage();
	}
	return 0.f;
}

float UAuraAbilitySystemLibrary::GetDebuffDuration(const FGameplayEffectContextHandle& EffectContextHandle)
{
	if (const FAuraGameplayEffectContext* AuraEffectContext = static_cast<const FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		return AuraEffectContext->GetDebuffDuration();
	}
	return 0.f;
}

float UAuraAbilitySystemLibrary::GetDebuffFrequency(const FGameplayEffectContextHandle& EffectContextHandle)
{
	if (const FAuraGameplayEffectContext* AuraEffectContext = static_cast<const FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		return AuraEffectContext->GetDebuffFrequency();
	}
	return 0.f;
}

FGameplayTag UAuraAbilitySystemLibrary::GetDamageType(const FGameplayEffectContextHandle& EffectContextHandle)
{
	if (const FAuraGameplayEffectContext* AuraEffectContext = static_cast<const FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		if (AuraEffectContext->GetDamageType().IsValid())
		{
			return *AuraEffectContext->GetDamageType();
		}
	}
	return FGameplayTag();
}

void UAuraAbilitySystemLibrary::SetIsSuccessfulDebuff(FGameplayEffectContextHandle& EffectContextHandle,
	bool bInSuccessfulDebuff)
{
	if (FAuraGameplayEffectContext* AuraEffectContext = static_cast<FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		AuraEffectContext->SetIsSuccessfulDebuff(bInSuccessfulDebuff);
	}
}

void UAuraAbilitySystemLibrary::SetDebuffDamage(FGameplayEffectContextHandle& EffectContextHandle, float InDamage)
{
	if (FAuraGameplayEffectContext* AuraEffectContext = static_cast<FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		AuraEffectContext->SetDebuffDamage(InDamage);
	}
}

void UAuraAbilitySystemLibrary::SetDebuffDuration(FGameplayEffectContextHandle& EffectContextHandle, float InDuration)
{
	if (FAuraGameplayEffectContext* AuraEffectContext = static_cast<FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		AuraEffectContext->SetDebuffDuration(InDuration);
	}
}

void UAuraAbilitySystemLibrary::SetDebuffFrequency(FGameplayEffectContextHandle& EffectContextHandle, float InFrequency)
{
	if (FAuraGameplayEffectContext* AuraEffectContext = static_cast<FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		AuraEffectContext->SetDebuffFrequency(InFrequency);
	}
}

void UAuraAbilitySystemLibrary::SetDamageType(FGameplayEffectContextHandle& EffectContextHandle,
	const FGameplayTag& InDamageType)
{
	if (FAuraGameplayEffectContext* AuraEffectContext = static_cast<FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		const TSharedPtr<FGameplayTag> DamageType = MakeShared<FGameplayTag>(InDamageType);
		AuraEffectContext->SetDamageType(DamageType);
	}
}
```





# Debuff in the Attribute Set

## 使用Debuff

### 在` ExecCalc_Damage `里处理

之前留在那里的if 为true的时候，从GameplayEffectSpec里拿到Context，继续填充Debuff相关的部分

虽然`Spec.GetContext()`返回的是值，但是这个值结构体内是有着指针的，所以直接用前面加的库函数set 指针里的值就行

```cpp
void UExecCalc_Damage::DetermineDebuff(const FGameplayEffectCustomExecutionParameters& ExecutionParams, const FGameplayEffectSpec& Spec, FAggregatorEvaluateParameters EvaluationParameters, const TMap<FGameplayTag, FGameplayEffectAttributeCaptureDefinition>& InTagsToDefs) const
{
    // ...
    if (bDebuff)
    {
        const float DebuffDamage = Spec.GetSetByCallerMagnitude(GameplayTags.Debuff_Damage, false, -1.f);
        const float DebuffDuration = Spec.GetSetByCallerMagnitude(GameplayTags.Debuff_Duration, false, -1.f);
        const float DebuffFrequency = Spec.GetSetByCallerMagnitude(GameplayTags.Debuff_Frequency, false, -1.f);

        FGameplayEffectContextHandle ContextHandle = Spec.GetContext();

        UAuraAbilitySystemLibrary::SetIsSuccessfulDebuff(ContextHandle, true);
        UAuraAbilitySystemLibrary::SetDebuffDamage(ContextHandle, DebuffDamage);
        UAuraAbilitySystemLibrary::SetDebuffDuration(ContextHandle, DebuffDuration);
        UAuraAbilitySystemLibrary::SetDebuffFrequency(ContextHandle, DebuffFrequency);
        UAuraAbilitySystemLibrary::SetDamageType(ContextHandle, DamageType);
    }
}
```



### 在` AuraAttributeSet`里处理

修改一下，把`PostGameplayEffectExecute`里每种属性的处理单独写成函数

```cpp
private:
	void HandleIncomingDamage(const FEffectProperties& Props);
	void HandleIncomingXP(const FEffectProperties& Props);
	void Debuff(const FEffectProperties& Props);
```



```cpp
void UAuraAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data)
{
    // ...
    if (Data.EvaluatedData.Attribute == GetIncomingDamageAttribute())
	{
		HandleIncomingDamage(Props);
	}
	if (Data.EvaluatedData.Attribute == GetIncomingXPAttribute())
	{
		HandleIncomingXP(Props);
	}
}

void UAuraAttributeSet::HandleIncomingDamage(const FEffectProperties& Props)
{
	const float LocalIncomingDamage = GetIncomingDamage();
	SetIncomingDamage(0.0f);
	if (LocalIncomingDamage > 0.0f)
	{
		const float NewHealth = GetHealth() - LocalIncomingDamage;
		SetHealth(FMath::Clamp(NewHealth, 0.0f, GetMaxHealth()));

		const bool bFatal = NewHealth <= 0.0f;
		if (bFatal)
		{
			if (ICombatInterface* CombatInterface = Cast<ICombatInterface>(Props.TargetAvatarActor))
			{
				CombatInterface->Die();
			}
			SendXPEvent(Props);
		}
		else
		{
			FGameplayTagContainer TagContainer;
			TagContainer.AddTag(FAuraGameplayTags::Get().Effects_HitReact);
			Props.TargetASC->TryActivateAbilitiesByTag(TagContainer);
		}

		const bool bBlock = UAuraAbilitySystemLibrary::IsBlockedHit(Props.EffectContextHandle);
		const bool bCriticalHit = UAuraAbilitySystemLibrary::IsCriticalHit(Props.EffectContextHandle);

		ShowFloatingText(Props, LocalIncomingDamage, bBlock, bCriticalHit);

		if (UAuraAbilitySystemLibrary::IsSuccessfulDebuff(Props.EffectContextHandle))
		{
			Debuff(Props);
		}
	}
}

void UAuraAttributeSet::HandleIncomingXP(const FEffectProperties& Props)
{
	const float LocalIncomingXP = GetIncomingXP();
	SetIncomingXP(0.f);
	// UE_LOG(LogAura, Log, TEXT("Incoming XP: %f"), LocalIncomingXP);
	if (Props.SourceCharacter->Implements<UPlayerInterface>() && Props.SourceCharacter->Implements<UCombatInterface>())
	{
		const int32 CurrentLevel = ICombatInterface::Execute_GetPlayerLevel(Props.SourceCharacter);
		const int32 CurrentXP = IPlayerInterface::Execute_GetXP(Props.SourceCharacter);
		const int32 NewLevel = IPlayerInterface::Execute_FindLevelForXP(Props.SourceCharacter, CurrentXP + LocalIncomingXP);
		const int32 NumLevelUps = NewLevel - CurrentLevel;

		// Level Up
		if (NumLevelUps > 0)
		{
			// Get AttributePointsReward and SpellPointsReward
			const int32 AttributePointsReward = IPlayerInterface::Execute_GetAttributePointsReward(Props.SourceCharacter, CurrentLevel);
			const int32 SpellPointsReward = IPlayerInterface::Execute_GetSpellPointsReward(Props.SourceCharacter, CurrentLevel);

			// Add to Player Level and AttributePoints and SpellPoints
			IPlayerInterface::Execute_AddToPlayerLevel(Props.SourceCharacter, NumLevelUps);
			IPlayerInterface::Execute_AddToAttributePoints(Props.SourceCharacter, AttributePointsReward);
			IPlayerInterface::Execute_AddToSpellPoints(Props.SourceCharacter, SpellPointsReward);

			// Fill up Health and Mana
			bTopOffHealth = true;
			bTopOffMana = true;

			IPlayerInterface::Execute_LevelUp(Props.SourceCharacter);
		}


		IPlayerInterface::Execute_AddToXP(Props.SourceCharacter, LocalIncomingXP);
	}
}

void UAuraAttributeSet::Debuff(const FEffectProperties& Props)
{

}
```





# Dynamic Gameplay Effects

## 动态的创建和应用新的GameplayEffect

之前是直接在蓝图里点一点，现在用cpp代码实现一下

动态创建的GameplayEffect本身是不支持Replicated的，要借助其他Replicated比如属性变化的那个时刻在客户端处理创建

Target如果死了就不再处理属性变更了

### 在` AuraAttributeSet`里处理

```cpp
#include "AuraAbilityTypes.h"

void UAuraAttributeSet::PostGameplayEffectExecute(const FGameplayEffectModCallbackData& Data)
{
    // ...
    if(Props.TargetCharacter->Implements<UCombatInterface>() && ICombatInterface::Execute_IsDead(Props.TargetCharacter))
    {
        return;
    }
}

void UAuraAttributeSet::Debuff(const FEffectProperties& Props)
{
    const FAuraGameplayTags& GameplayTags = FAuraGameplayTags::Get();
    FGameplayEffectContextHandle EffectContext = Props.SourceASC->MakeEffectContext();
    EffectContext.AddSourceObject(Props.SourceAvatarActor);
    
    const FGameplayTag DamageType = UAuraAbilitySystemLibrary::GetDamageType(Props.EffectContextHandle);
	const float DebuffDamage = UAuraAbilitySystemLibrary::GetDebuffDamage(Props.EffectContextHandle);
	const float DebuffDuration = UAuraAbilitySystemLibrary::GetDebuffDuration(Props.EffectContextHandle);
	const float DebuffFrequency = UAuraAbilitySystemLibrary::GetDebuffFrequency(Props.EffectContextHandle);
    
    FString DebuffName = FString::Printf(TEXT("DynamicDebuff_%s"), *DamageType.ToString());
    UGameplayEffect* Effect = NewObject<UGameplayEffect>(GetTransientPackage(), FName(DebuffName));
    Effect->DurationPolicy = EGameplayEffectDurationType::HasDuration;
    Effect->Period = DebuffFrequency;
    Effect->DurationMagnitude = FScalableFloat(DebuffDuration);
    
    Effect->InheritableOwnedTagsContainer.AddTag(GameplayTags.DamageTypesToDebuffs[DamageType]);
    
    Effect->StackingType = EGameplayEffectStackingType:: AggregateBySource;
    Effect->StackLimitCount = 1;
    
    const int32 Index = Effect->Modifiers.Num();
    Effect->Modifiers.Add(FGameplayModifierInfo());
    FGameplayModifierInfo& ModifierInfo = Effect->Modifiers[Index];
    
    ModifierInfo.ModifierMagnitude = FScalableFloat(DebuffDamage);
    ModifierInfo.ModifierOp = EGameplayModOp::Additive;
    ModifierInfo.Attribute = UAuraAttributeSet::GetInComingDamageAttribute();

    if(FGameplayEffectSpec* MutableSpec = new FGameplayEffectSpec(Effect, EffectContext, 1.0f))
    {
        FAuraGameplayEffectContext* AuraContext = static_cast<FAuraGameplayEffectContext*>(MutableSpec->GetContext().Get());
        TSharedPtr<FGameplayTag> DebuffDamageType = MakeShareable(new FGameplayTag(DamageType));
        AuraContext->SetDamageType(DebuffDamageType);
        Props.TargetASC->ApplyGameplayEffectSpecToSelf(*MutableSpec);
    }
}
```





# Debuff Niagara Component

## Debuff的粒子特效组件

用cpp的` NiagaraComponent `来处理，当有debuff的时候激活，debuff结束了取消激活，可以节省创建的开销

### 在`Aura.Build.cs`里添加Niagara的Module



### 在` CombatInterface `里加个委托，处理客户端上` NiagaraComponent `的Owner的ASC还没被设置完毕的特殊情况

```cpp
DECLARE_MULTICAST_DELEGATE_OneParam(FOnASCRegistered, UAbilitySystemComponent*)
    
public:
	virtual FOnASCRegistered GetOnASCRegisteredDelegate() = 0;
```



### 在` AuraCharacterBase`里处理

顺便处理一下角色死亡时取消激活一下

```cpp
public:
	virtual FOnASCRegistered GetOnASCRegisteredDelegate() override;
	
	FOnASCRegistered OnAscRegistered;

protected:
	UPROPERTY(VisibleAnywhere)
	TObjectPtr<UDebuffNiagaraComponent> BurnDebuffComponent;
```



```cpp
#include "AbilitySystem/Debuff/DebuffNiagaraComponent.h"


AAuraCharacterBase::AAuraCharacterBase()
{
    // ...
    const FAuraGameplayTags& GameplayTags = FAuraGameplayTags::Get();
	
	BurnDebuffComponent = CreateDefaultSubobject<UDebuffNiagaraComponent>("BurnDebuffComponent");
	BurnDebuffComponent->SetupAttachment(GetRootComponent());
	BurnDebuffComponent->DebuffTag = GameplayTags.Debuff_Burn;
}

void AAuraCharacterBase::MulticastHandleDeath_Implementation()
{
    // ...
    BurnDebuffComponent->Deactivate();
}

FOnASCRegistered AAuraCharacterBase::GetOnASCRegisteredDelegate()
{
	return OnAscRegistered;
}
```



### 在` AuraEnemy`里处理

```cpp
void AAuraEnemy::InitAbilityActorInfo()
{
    // ...
    OnAscRegistered.Broadcast(AbilitySystemComponent);
}
```



### 在 `AuraCharacter `里处理

```cpp
void AAuraCharacter::InitAbilityActorInfo()
{
    // ...
    OnAscRegistered.Broadcast(AbilitySystemComponent);
}
```



### 创建` DebuffNiagaraComponent`

放在` Aura\Public\AbilitySystem\Debuff`

继承自` NiagaraComponent `

```cpp
#include "GameplayTagContainer.h"

public:
	UDebuffNiagaraComponent();

	UPROPERTY(VisibleAnywhere)
	FGameplayTag DebuffTag;

protected:
	virtual void BeginPlay() override;
	void DebuffTagChanged(const FGameplayTag CallbackTag, int32 NewCount);
```



```cpp
#include "AbilitySystemBlueprintLibrary.h"
#include "AbilitySystemComponent.h"
#include "Interaction/CombatInterface.h"


UDebuffNiagaraComponent::UDebuffNiagaraComponent()
{
	bAutoActivate = false;
}

void UDebuffNiagaraComponent::BeginPlay()
{
    Super::BeginPlay();
    
    ICombatInterface* CombatInterface = Cast<ICombatInterface>(GetOwner());
    if (UAbilitySystemComponent* ASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(GetOwner()))
    {
        ASC->RegisterGameplayTagEvent(DebuffTag, EGameplayTagEventType::NewOrRemoved).AddUObject(this, &UDebuffNiagaraComponent::DebuffTagChanged);
    }
    else if(CombatInterface)
    {
        CombatInterface->GetOnASCRegisteredDelegate().AddWeakLambda(this, [this](UAbilitySystemComponent* InASC)
		{
			InASC->RegisterGameplayTagEvent(DebuffTag, EGameplayTagEventType::NewOrRemoved).AddUObject(this, &UDebuffNiagaraComponent::DebuffTagChanged);
		});
    }
}

void UDebuffNiagaraComponent::DebuffTagChanged(const FGameplayTag CallbackTag, int32 NewCount)
{
	if (NewCount > 0)
	{
		Activate();
	}
	else
	{
		Deactivate();
	}
}
```



### 给每种角色都设置一下`BurnDebuffComponent`

`BurnDebuffComponent`的`NiagaraSystemAsset`设置为`NS_Fire`

选中`BurnDebuffComponent`的`Auto Activate`然后在Viewport里根据显示修改位置





# Death Impulse Magnitude

## 当角色被击杀的时候加个冲击力让他被打飞出去

### 在` AuraAbilityTypes`里处理

```cpp
struct FDamageEffectParams
{
    // ...
    UPROPERTY()
	float DeathImpulseMagnitude = 0.f;
}
```



### 在` AuraDamageGameplayAbility`里处理

```cpp
protected:
	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	float DeathImpulseMagnitude = 60.f;
```



```cpp
FDamageEffectParams UAuraDamageGameplayAbility::MakeDamageEffectParamsFromClassDefaults(AActor* TargetActor) const
{
    // ...
    Params.DeathImpulseMagnitude = DeathImpulseMagnitude;
}
```





# Death Impulse in the Effect Context

## 把死亡冲击力加到EffectContext里

### 在` AuraAbilityTypes`里处理

除了前面加的冲击力，还要加个冲击的朝向

`FVector`有自己单独的`NetSerialize`

```cpp
struct FDamageEffectParams
{
    // ...
    UPROPERTY()
	FVector DeathImpulse = FVector::ZeroVector;
}


public:
	FVector GetDeathImpulse() const { return DeathImpulse; }
	void SetDeathImpulse(const FVector& InImpulse) { DeathImpulse = InImpulse; }

protected:
	UPROPERTY()
	FVector DeathImpulse = FVector::ZeroVector;
```



```cpp
bool FAuraGameplayEffectContext::NetSerialize(FArchive& Ar, UPackageMap* Map, bool& bOutSuccess)
{
    // ...
    if (!DeathImpulse.IsZero())
    {
        RepBits |= 1 << 14;
    }
    
    // ...
    Ar.SerializeBits(&RepBits, 14);
    
    // ...
    if (RepBits & (1 << 14))
	{
		DeathImpulse.NetSerialize(Ar, Map, bOutSuccess);
	}
}
```



### 在` AuraAbilitySystemLibrary`里处理

```cpp
public:
	UFUNCTION(BlueprintPure, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static FVector GetDeathImpulse(const FGameplayEffectContextHandle& EffectContextHandle);

	UFUNCTION(BlueprintCallable, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static void SetDeathImpulse(UPARAM(ref) FGameplayEffectContextHandle& EffectContextHandle, const FVector& InImpulse);
```



```cpp
FVector UAuraAbilitySystemLibrary::GetDeathImpulse(const FGameplayEffectContextHandle& EffectContextHandle)
{
	if (const FAuraGameplayEffectContext* AuraEffectContext = static_cast<const FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		return AuraEffectContext->GetDeathImpulse();
	}
	return FVector::ZeroVector;
}

void UAuraAbilitySystemLibrary::SetDeathImpulse(FGameplayEffectContextHandle& EffectContextHandle,
	const FVector& InImpulse)
{
	if (FAuraGameplayEffectContext* AuraEffectContext = static_cast<FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		AuraEffectContext->SetDeathImpulse(InImpulse);
	}
}

FGameplayEffectContextHandle UAuraAbilitySystemLibrary::ApplyDamageEffect(const FDamageEffectParams& DamageEffectParams)
{
    // ...
    SetDeathImpulse(EffectContexthandle, DamageEffectParams.DeathImpulse);
}
```



### 在` AuraProjectile `里处理

当子弹产生overlap的时候才计算冲击力的朝向

```cpp
void AAuraProjectile::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	// ...
    if (UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OtherActor))
    {
        const FVector DeathImpulse = GetActorForwardVector() * DamageEffectParams.DeathImpulseMagnitude;
		DamageEffectParams.DeathImpulse = DeathImpulse;
    }
}
```





# Handling Death Impulse

## 处理死亡的冲击力

### 在` AuraAttributeSet `里处理

死的时候从EffectContext里拿到DeathImpulse通过`Die`接口传给Character

```cpp
void UAuraAttributeSet::HandleIncomingDamage(const FEffectProperties& Props)
{
	// ...
    FVector Impulse = UAuraAbilitySystemLibrary::GetDeathImpulse(Props.EffectContextHandle);
	CombatInterface->Die(Impulse);
}
```



### 在` CombatInterface `里处理

```cpp
public:
	virtual void Die(const FVector& DeathImpulse) = 0;
```



### 在` AuraCharacterBase`里处理

`AddImpulse`的时候最后一个参数填true，忽略重力带来的影响

武器加个单独的权重，先写死0.1，后面要改再提成参数在蓝图里配

```cpp
public:
	virtual void Die(const FVector& DeathImpulse) override;	
	virtual void MulticastHandleDeath(const FVector& DeathImpulse);
```



```cpp
void AAuraCharacterBase::Die(const FVector& DeathImpulse)
{
    // ...
    MulticastHandleDeath(DeathImpulse);
}

void AAuraCharacterBase::MulticastHandleDeath_Implementation(const FVector& DeathImpulse)
{
    Weapon->AddImpulse(DeathImpulse * 0.1f, NAME_None, true);
    GetMesh()->AddImpulse(DeathImpulse, NAME_None, true);
}
```



### 在` AuraEnemy `里处理

```cpp
virtual void Die(const FVector& DeathImpulse) override;
```



```cpp
void AAuraEnemy::Die(const FVector& DeathImpulse)
{
    // ...
    Super::Die(DeathImpulse);
}
```



### 在` DebuffNiagaraComponent`里处理

激活的时候加个判断，没死才加，这样可以避免火球本身的伤害把敌人打死了但是火球同步产生的debuff导致特效激活了

```cpp
void UDebuffNiagaraComponent::DebuffTagChanged(const FGameplayTag CallbackTag, int32 NewCount)
{
    const bool bOwnerValid = IsValid(GetOwner());
	const bool bOwnerAlive = GetOwner()->Implements<UCombatInterface>() && !ICombatInterface::Execute_IsDead(GetOwner());
    
    if (NewCount > 0 && bOwnerValid && bOwnerAlive)
	{
		Activate();
	}
}
```





## 当角色被点燃时不产生HitReact

### 在` GA_HitReact `里处理

`Activation Blocked Tags`里添加上`Debuff.Burn`





# Knockback

## 加个击退

### 用`LaunchCharacter`而不是`AddImpulse`的原因

不需要给Character添加RagDoll或者是启用模拟物理SimulatePhysics



### 在`AuraAbilityTypes`里处理

把`FDamageEffectParams`的参数都加个`BlueprintReadWrite`

加个击退力数值，加个击退概率，加个击退力，击退力给加到EffectContext里用来在整个技能结算流程里使用

```cpp
struct FDamageEffectParams
{
	// ...
    UPROPERTY(BlueprintReadWrite)
	float KnockbackForceMagnitude = 0.f;

	UPROPERTY(BlueprintReadWrite)
	float KnockbackChance = 0.f;

	UPROPERTY(BlueprintReadWrite)
	FVector KnockbackForce = FVector::ZeroVector;
}

public:
	FVector GetKnockbackForce() const { return KnockbackForce; }
	void SetKnockbackForce(const FVector& InForce) { KnockbackForce = InForce; }

protected:
	UPROPERTY()
	FVector KnockbackForce = FVector::ZeroVector;
```



```cpp
bool FAuraGameplayEffectContext::NetSerialize(FArchive& Ar, UPackageMap* Map, bool& bOutSuccess)
{
    // ...
    if (!KnockbackForce.IsZero())
    {
        RepBits |= 1 << 15;
    }
    
    Ar.SerializeBits(&RepBits, 15);
    
    if (RepBits & (1 << 15))
	{
		KnockbackForce.NetSerialize(Ar, Map, bOutSuccess);
	}
}
```



### 在`AuraAbilitySystemLibrary`里处理

加个函数从EffectContext里Get以及Set进去

```cpp
public:
	UFUNCTION(BlueprintPure, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static FVector GetKnockbackForce(const FGameplayEffectContextHandle& EffectContextHandle);

	UFUNCTION(BlueprintCallable, Category = "AuraAbilitySystemLibrary|GameplayEffects")
	static void SetKnockbackForce(UPARAM(ref) FGameplayEffectContextHandle& EffectContextHandle, const FVector& InForce);
```



```cpp
FVector UAuraAbilitySystemLibrary::GetKnockbackForce(const FGameplayEffectContextHandle& EffectContextHandle)
{
	if (const FAuraGameplayEffectContext* AuraEffectContext = static_cast<const FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		return AuraEffectContext->GetKnockbackForce();
	}
	return FVector::ZeroVector;
}

void UAuraAbilitySystemLibrary::SetKnockbackForce(FGameplayEffectContextHandle& EffectContextHandle,
	const FVector& InForce)
{
	if (FAuraGameplayEffectContext* AuraEffectContext = static_cast<FAuraGameplayEffectContext*>(EffectContextHandle.Get()))
	{
		AuraEffectContext->SetKnockbackForce(InForce);
	}
}

FGameplayEffectContextHandle UAuraAbilitySystemLibrary::ApplyDamageEffect(const FDamageEffectParams& DamageEffectParams)
{
    // ...
    SetKnockbackForce(EffectContexthandle, DamageEffectParams.KnockbackForce);
}
```



### 在` AuraDamageGameplayAbility`里处理

把`MakeDamageEffectParamsFromClassDefaults`加个`BlueprintPure`，在蓝图中每次使用的时候都执行一次，`BlueprintPure`相比于`BlueprintCallable`不会有执行引脚，而且返回值不会创建局部变量

`MakeDamageEffectParamsFromClassDefaults`里也设置一下`KnockbackForce`，这样如果从蓝图里使用可以有个击退的默认值

```cpp
public:
	UFUNCTION(BlueprintPure)
	FDamageEffectParams MakeDamageEffectParamsFromClassDefaults(AActor* TargetActor = nullptr) const;

protected:
	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	float KnockbackForceMagnitude = 1000.f;

	UPROPERTY(EditDefaultsOnly, Category = "Damage")
	float KnockbackChance = 0.f;
```



```cpp
FDamageEffectParams UAuraDamageGameplayAbility::MakeDamageEffectParamsFromClassDefaults(AActor* TargetActor) const
{
    // ...
    Params.KnockbackForceMagnitude = KnockbackForceMagnitude;
	Params.KnockbackChance = KnockbackChance;
	if (IsValid(TargetActor))
	{
		FRotator Rotation = (TargetActor->GetActorLocation() - GetAvatarActorFromActorInfo()->GetActorLocation()).Rotation();
		Rotation.Pitch = 45.f;
		const FVector ToTarget = Rotation.Vector();
		Params.DeathImpulse = ToTarget * DeathImpulseMagnitude;
		Params.KnockbackForce = ToTarget * KnockbackForceMagnitude;
	}    
}
```



### 在` AuraProjectile `里处理

每次Overlap的时候算一下这次攻击击退没有，把值塞到Params里

KnockbackForce加个朝上45度的角度

```cpp
void AAuraProjectile::OnSphereOverlap(UPrimitiveComponent* OverlappedComponent, AActor* OtherActor, UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult)
{
	// ...
    if (UAbilitySystemComponent* TargetASC = UAbilitySystemBlueprintLibrary::GetAbilitySystemComponent(OtherActor))
    {
        const bool bKnockback = FMath::RandRange(1, 100) < DamageEffectParams.KnockbackChance;
        if (bKnockback)
        {
            FRotator Rotation = GetActorRotation();
            Rotation.Pitch = 45.f;

            const FVector KnockbackDirection = Rotation.Vector();
            const FVector KnockbackForce = KnockbackDirection * DamageEffectParams.KnockbackForceMagnitude;
            DamageEffectParams.KnockbackForce = KnockbackForce;
        }
        // ...
    }
}
```



### 在`AuraAttribuetSet`里处理

如果IncomingDamage没有致死，则调用`LaunchCharacter`处理击退

```cpp
void UAuraAttributeSet::HandleIncomingDamage(const FEffectProperties& Props)
{
    // ...
    const bool bFatal = NewHealth <= 0.f;
    if(bFatal)
    {
        // ...
    }
    else
    {
        const FVector& KnockbackForce = UAuraAbilitySystemLibrary::GetKnockbackForce(Props.EffectContextHandle);
        if (!KnockbackForce.IsNearlyZero(1.f))
        {
            Props.TargetCharacter->LaunchCharacter(KnockbackForce, true, true);
        }
    }
}
```



### 在`GA_MeleeAttack`里处理

给近战怪加个攻击击退

`Is Not Friend`为true->`ForEachLoop`的ArrayElement的`Make Dmaage Effect Params From Class Defaults`->`Apply Damage Effect`->`Set HasHitReact`

![1712232068706](E:\Typora\TyporaPic\1712232068706.png)



### 在`ABP_Aura`里处理

当Aura被击飞在空中时取消混合的跑步姿势

转到`Event Graph`

`UpdateAnimation`里加个Sequence，以前的部分放在前面

Sequence->`CharacterMovement`的`IsFalling`给`Promote to Variable`命名为`IsFalling`

![1712232098774](E:\Typora\TyporaPic\1712232098774.png)



在`Main States`里，`Add Status Alias`命名为`ToInAir`选择`Idle`和`Running`->`InAir`如果`IsFalling`为true

`InAir`->`Idle`如果`IsFalling`为false

![1712232084563](E:\Typora\TyporaPic\1712232084563.png)



## 敌人飞不出地图关卡外

### 在关卡编辑器中处理

在地图的墙外面都加个`Blocking Volume`，`Scale.Z`设置的大一点



























