# Spell Menu Design

## 设计技能菜单

![1711700228073](E:\Typora\TyporaPic\1711700228073.png)





# Spell Globe Button

## 技能球按钮

### 创建`WBP_SpellGlobe_Button`

放在` Content\Blueprints\UI\SpellGlobes`下

复制一份`WBP_ValueGlobe`

删去`Text_Value`和`Image_Ring`，删去`Bind Event to On PlayerLevelChanged Delegate`，删去`SetCooldownState`、`SetDefaultState`、`HideCooldownText`、`UpdateCooldownTimer`、`UpdateRingBrush`



`Image_Background`的`Brush Image`换成`MI_LockedBG`

`BackgroundBrush`的默认值也改成`MI_LockedBG`



添加一个Image命名为`Image_Icon`放在`Overlay_Root`下设置为变量，层级在最前，Alignment设置为Fill，`Brush Image`选择`Locked_sm`

添加一个Image命名为`Image_Selection`放在`Overlay_Root`下设置为变量，层级在最前，Alignment设置为Fill，`Brush Image`选择`SelectionCircle`，`Render Opacity`为0

添加一个Button命名为`Button_Ring`放在`Overlay_Root`下设置为变量，层级在最前

```
`Style Normal`里`Image`设置为`SkillRing_1`，`Tint`改成1，`Draw As`选择`Image`；
`Style Hovered`里`Image`设置为`SkillRing_1_Glow`，`Tint`改成1，`Draw As`选择`Image`；
`Style Pressed`里`Image`设置为`SkillRing_1_Glow`，`Tint`为默认值不变，`Draw As`选择`Image`；
`Style Disabled`里`Image`设置为`SkillRing_1`，`Tint`改成1，`Draw As`选择`Image`
```



选中`Image_Selection`添加一个动画命名为`SelectAnimation`，添加一个Track

添加一个`Transform`的子Track，第0秒的时候Scale为(1.5,1.5)，第0.05秒的时候Scale为(1.25,1.25)

![1711703023981](E:\Typora\TyporaPic\1711703023981.png)





# Offensive Spell Tree

## 主动技能树

### 创建` WBP_OffensiveSpellTree`

放在` Content\Blueprints\UI\SpellMenu`下

继承自`AuraUserWidget`

显示改成`Desired`

添加一个`SizeBox`命名为`SizeBox_Root`设置为变量

添加一个`WrapBox`命名为`WrapBox_Root`放在`SizeBox_Root`下设置为变量，Alignment设置为Center，`Orientation`改成`Vertical`



添加一个`WrapBox`命名为`WrapBox_Col_1`放在`WrapBox_Root`下设置为变量，Alignment设置为Fill，`Orientation`改成`Vertical`

添加一个`Spacer`命名为放在`WrapBox_Root`，Size改成(50,100)

添加一个`WrapBox`命名为`WrapBox_Col_2`放在`WrapBox_Root`下设置为变量，Alignment设置为Fill

添加一个`Spacer`命名为放在`WrapBox_Root`，Size改成(50,100)

添加一个`WrapBox`命名为`WrapBox_Col_3`放在`WrapBox_Root`下设置为变量，Alignment设置为Fill



添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Col_1`下设置为变量

添加一个`Image`命名为放在`WrapBox_Col_1`下设置为变量，`Brush Image`选择`Line`，`ImageSize`改成(32,15)

添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Col_1`下设置为变量

添加一个`Image`命名为放在`WrapBox_Col_1`下设置为变量，`Brush Image`选择`Line`，`ImageSize`改成(32,15)

添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Col_1`下设置为变量



添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Col_2`下设置为变量

添加一个`Image`命名为放在`WrapBox_Col_2`下设置为变量，`Brush Image`选择`Line`，`ImageSize`改成(32,15)

添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Col_2`下设置为变量

添加一个`Image`命名为放在`WrapBox_Col_2`下设置为变量，`Brush Image`选择`Line`，`ImageSize`改成(32,15)

添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Col_2`下设置为变量



添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Col_3`下设置为变量

添加一个`Image`命名为放在`WrapBox_Col_3`下设置为变量，`Brush Image`选择`Line`，`ImageSize`改成(32,15)

添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Col_3`下设置为变量

添加一个`Image`命名为放在`WrapBox_Col_3`下设置为变量，`Brush Image`选择`Line`，`ImageSize`改成(32,15)

添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Col_3`下设置为变量

![1711703039978](E:\Typora\TyporaPic\1711703039978.png)



转到`Event Graph`

添加float类型的`BoxWidth`和float类型的变量`BoxHeight`，`Category`填`SpellTree Properties`，默认值分别填525和350

`Event Pre Construct`->`SizeBoxRoot`的`SetWidthOverride`->`SizeBoxRoot`的`SetHeightOverride`，全部圈起来重命名为`UpdateBoxSize`函数

![1711703060896](E:\Typora\TyporaPic\1711703060896.png)





# Passive Spell Tree

## 被动技能树

### 创建` WBP_PassiveSpellTree`

放在` Content\Blueprints\UI\SpellMenu`下

复制一份` WBP_OffensiveSpellTree`

删掉`WrapBox_Col_1`、`WrapBox_Col_2`、`WrapBox_Col_3`

`BoxHeight`默认值改成100



添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Root`下设置为变量，Alignment设置为Center，`BoxWidth`和`BoxHeight`改成60，`Glass Padding`改成4.5

添加一个`Spacer`命名为放在`WrapBox_Root`，Size改成(100,50)

添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Root`下设置为变量，Alignment设置为Center，`BoxWidth`和`BoxHeight`改成60

添加一个`Spacer`命名为放在`WrapBox_Root`，Size改成(100,50)

添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Root`下设置为变量，Alignment设置为Center，`BoxWidth`和`BoxHeight`改成60

![1711703677629](E:\Typora\TyporaPic\1711703677629.png)





# Equipped Spell Row

## 装备技能栏

### 创建` WBP_EquippedSpellRow`

放在` Content\Blueprints\UI\SpellMenu`下

复制一份` WBP_PassiveSpellTree`

删掉`WrapBox_Root`

`BoxHeight`默认值改成140



重新添加一个WrapBox命名为`WrapBox_Root`，`Horizontal Alignment`设置为Fill，`Vertical Alignment`设置为Center，`Content Layout`的`Horizontal Alignment`设置为Center



添加一个`VerticalBox`放在`WrapBox_Root`下命名为`VerticalBox_Offensive`

添加一个`VerticalBox`放在`WrapBox_Root`下命名为`VerticalBox_Passive`



添加一个`Text`命名为放在`VerticalBox_Offensive`下，Alignment改成Center，文本填Offensive，`Font Family`为`PirataOne`，FontSize为14，OutlineSize为1，Justification为Center

添加一个`WrapBox`在`VerticalBox_Offensive`下命名为`WrapBox_Offensive`



添加一个`Text`命名为放在`VerticalBox_Offensive`下，Alignment改成Center，文本填Passive，`Font Family`为`PirataOne`，FontSize为14，OutlineSize为1，Justification为Center

添加一个`WrapBox`在`VerticalBox_Passive`下命名为`WrapBox_Passive`，`Orientation`改成`Vertical`



添加一个`VerticalBox`命名为放在`WrapBox_Offensive`下命名为`Box_LMB`

添加一个`Text`命名为放在`Box_LMB`下，文本填LMB，`Font Family`为`Amarante`，FontSize为10，OutlineSize为1，Justification为Center

添加一个`WBP_SpellGlobeButton`命名为放在`Box_LMB`下设置为变量，Alignment设置为Center，`BoxWidth`和`BoxHeight`改成60，Padding改成5



添加一个Spacer放在`WrapBox_Offensive`下，，Size改成(5,1)



添加一个`VerticalBox`命名为放在`WrapBox_Offensive`下命名为`Box_RMB`

添加一个`Text`命名为放在`Box_RMB`下，文本填RMB，`Font Family`为`Amarante`，FontSize为10，OutlineSize为1，Justification为Center

添加一个`WBP_SpellGlobeButton`命名为放在`Box_RMB`下设置为变量，Alignment设置为Center，`BoxWidth`和`BoxHeight`改成60，Padding改成5



添加一个Spacer放在`WrapBox_Offensive`下，，Size改成(5,1)



添加一个`VerticalBox`命名为放在`WrapBox_Offensive`下命名为`Box_1`

添加一个`Text`命名为放在`Box_1`下，文本填1，`Font Family`为`Amarante`，FontSize为10，OutlineSize为1，Justification为Center

添加一个`WBP_SpellGlobeButton`命名为放在`Box_1`下设置为变量，Alignment设置为Center，`BoxWidth`和`BoxHeight`改成60，Padding改成5



添加一个Spacer放在`WrapBox_Offensive`下，，Size改成(5,1)



添加一个`VerticalBox`命名为放在`WrapBox_Offensive`下命名为`Box_2`

添加一个`Text`命名为放在`Box_2`下，文本填2，`Font Family`为`Amarante`，FontSize为10，OutlineSize为1，Justification为Center

添加一个`WBP_SpellGlobeButton`命名为放在`Box_2`下设置为变量，Alignment设置为Center，`BoxWidth`和`BoxHeight`改成60，Padding改成5



添加一个Spacer放在`WrapBox_Offensive`下，，Size改成(5,1)



添加一个`VerticalBox`命名为放在`WrapBox_Offensive`下命名为`Box_3`

添加一个`Text`命名为放在`Box_3`下，文本填3，`Font Family`为`Amarante`，FontSize为10，OutlineSize为1，Justification为Center

添加一个`WBP_SpellGlobeButton`命名为放在`Box_3`下设置为变量，Alignment设置为Center，`BoxWidth`和`BoxHeight`改成60，Padding改成5



添加一个Spacer放在`WrapBox_Offensive`下，，Size改成(5,1)



添加一个`VerticalBox`命名为放在`WrapBox_Offensive`下命名为`Box_4`

添加一个`Text`命名为放在`Box_4`下，文本填4，`Font Family`为`Amarante`，FontSize为10，OutlineSize为1，Justification为Center

添加一个`WBP_SpellGlobeButton`命名为放在`Box_4`下设置为变量，Alignment设置为Center，`BoxWidth`和`BoxHeight`改成60，Padding改成5



添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Passive`下设置为变量，`Horizontal Alignment`设置为Center，`Vertical Alignment`设置为Fill，`BoxWidth`和`BoxHeight`改成45，Padding改成4

添加一个`Spacer`放在`WrapBox_Root`下，Size为(1,2.5)

添加一个`WBP_SpellGlobeButton`命名为放在`WrapBox_Passive`下设置为变量，Alignment设置为Center，`BoxWidth`和`BoxHeight`改成45，Padding改成4

![1711705978845](E:\Typora\TyporaPic\1711705978845.png)





# Spell Menu Widget

## 技能菜单

### 修改`WBP_OffensiveSpellTree`

`BoxWidth`改成450

`WBP_SpellGlobeButton`的`BoxWidth`和`BoxHeight`改成80

`Image_Line`的`ImageSize`改成(32,30)

`Spacer`改成(75,100)



### 修改`WBP_PassiveSpellTree`

`BoxWidth`改成450



### 修改`WBP_EquippedSpellRow`

`BoxWidth`改成450



### 创建` WBP_SpellMenu`

放在` Content\Blueprints\UI\SpellMenu`下

复制一份`WBP_AttributeMenu`

`ATTRIBUTES`改成`ABILITIES`，从紧挨着的Spacer全部删掉

清空`Event Graph`的内容，删掉`Event Dispatchers`，删掉所有的函数



`WrapBox`的Padding改成40

添加`HorizontalBox`命名为`HorizontalBox_Root`放在`WrapBox`的Spacer下



添加`WrapBox`放在`HorizontalBox_Root`下命名为`WrapBox_TreeSide`，`Size`为Auto，Alignment为Fill

添加`WrapBox`放在`HorizontalBox_Root`下命名为`WrapBox_DescriptionSide`



添加一个`Spacer`放在`WrapBox_TreeSide`下，Size为(486,20)

添加`HorizontalBox`放在`WrapBox_TreeSide`下命名为`HorizontalBox_SpellPoints`，`Size`为Auto，Alignment为Center，选中`Fill Empty Space`



添加一个`Text`命名为放在`HorizontalBox_SpellPoints`下，文本填Spell Points，`Font Family`为`PirataOne`，FontSize为20，OutlineSize为1，Justification为Center，LetterSpacing为150

添加一个`Spacer`放在`HorizontalBox_SpellPoints`下，Size为(20,1)

添加`WBP_FramedValue`放在`HorizontalBox_SpellPoints`下，Alignment改成Center

添加一个`Spacer`放在`HorizontalBox_SpellPoints`下，Size为(20,1)

添加`WBP_WideButton`放在`HorizontalBox_SpellPoints`下，文本改成`Spend Point`，LetterSpacing为100，`BoxWidth`和`BoxHeight`改成(180,60)



添加一个`Spacer`放在`WrapBox_TreeSide`下，Size为(400,20)



添加一个`Text`命名为放在`WrapBox_TreeSide`下，文本填OFFENSIVE ABILITIES，`Font Family`为`PirataOne`，FontSize为20，OutlineSize为1，Justification为Center，LetterSpacing为600，颜色浅橘色

添加`WBP_OffensiveSpellTree`放在`WrapBox_TreeSide`下，选中`Fill Empty Space`

添加一个`Text`命名为放在`WrapBox_TreeSide`下，文本填PASSIVE ABILITIES，`Font Family`为`PirataOne`，FontSize为20，OutlineSize为1，Justification为Center，LetterSpacing为600，颜色浅橘色

添加`WBP_PassiveSpellTree`放在`WrapBox_TreeSide`下，选中`Fill Empty Space`

添加一个`Text`命名为放在`WrapBox_TreeSide`下，文本填EQUIPPED ABILITIES，`Font Family`为`PirataOne`，FontSize为20，OutlineSize为1，Justification为Center，LetterSpacing为600，颜色浅橘色

添加`WBP_EquippedSpellRow`放在`WrapBox_TreeSide`下，选中`Fill Empty Space`

![1711710434556](E:\Typora\TyporaPic\1711710434556.png)





# Spell Description Box

## 添加技能描述框

### 创建` MI_Flowing_Scroll`

放在` Content\Assets\UI\Globes`下

复制一份`MI_Flowing_Red`

颜色改成深蓝色



### 在` WBP_SpellMenu`里处理

加个`Spacer`放在`WrapBox_DescriptionSide`下，勾选`Force NewLine`，Size为(120,40)

加个`Spacer`放在`WrapBox_DescriptionSide`下，勾选`Force NewLine`，Size为(40,1)

添加一个`Text`命名为放在`WrapBox_DescriptionSide`下，勾选`Fill Empty Space`，文本填Description，`Font Family`为`PirataOne`，FontSize为20，OutlineSize为1，Justification为`Center`，LetterSpacing为150，颜色浅橘色

加个`Spacer`放在`WrapBox_DescriptionSide`下，勾选`Force NewLine`，Size为(120,20)

添加一个`SizeBox`放在`WrapBox_DescriptionSide`下命名为`SizeBox_CurrentLevel`，勾选`Force NewLine`，Width和Height为(220,250)

加个`Spacer`放在`WrapBox_DescriptionSide`下，勾选`Force NewLine`，Size为(120,40)

添加一个`SizeBox`放在`WrapBox_DescriptionSide`下命名为`SizeBox_NextLevel`，勾选`Force NewLine`，Width和Height为(220,250)

加个`Spacer`放在`WrapBox_DescriptionSide`下，勾选`Force NewLine`，Size为(120,120)

加个`Spacer`放在`WrapBox_DescriptionSide`下，勾选`Force NewLine`，Size为(180,20)



添加一个Overlay放在`SizeBox_CurrentLevel`下命名为`Overlay_CurrentLevel`

添加一个Overlay放在`SizeBox_NextLevel`下



添加一个`Image`到`Overlay_CurrentLevel`下，Padding填2，Alignment为Fill，`Brush Image`为` MI_Flowing_Scroll`，`Draw As`选择`Image`

添加一个`Image`到`Overlay_CurrentLevel`下，Alignment为Fill，`Brush Image`为`Border_Large`，`Draw As`选择`Border`，`Margin`为0.25

添加一个`ScrollBox`到`Overlay_CurrentLevel`下命名为`ScrollBox_CurrentLevel`，Alignment为Fill



添加一个`Image`到`SizeBox_NextLevel`下，Padding填2，Alignment为Fill，`Brush Image`为` MI_Flowing_Scroll`，`Draw As`选择`Image`

添加一个`Image`到`SizeBox_NextLevel`下，Alignment为Fill，`Brush Image`为`Border_Large`，`Draw As`选择`Border`，`Margin`为0.25

添加一个`ScrollBox`到`Overlay_CurrentLevel`下命名为`ScrollBox_NextLevel`，Alignment为Fill=



添加一个`WBP_Button`命名为`CloseButton`放在`Overlay_Box`下

![1711711988212](E:\Typora\TyporaPic\1711711988212.png)





# Spell Menu Button

## 添加显示和关闭技能菜单的按钮

### 在` WBP_SpellMenu`里处理

添加一个`Event Dispatchers`命名为`SpellMenuClosed`

`Event Construct`->`Close Button`的`Get Button`的`Assign On Clicked`->`Remove From Parent`

`Event Destruct`->`SpellMenuClosed`

![1711714460745](E:\Typora\TyporaPic\1711714460745.png)



### 在`WBP_Overlay`里处理

加个float类型的变量命名为`MenuPadding`默认值为25



加个`WBP_WideButton`命名为`SpellMenuButton`放在蓝条球右边设置为变量，`ButtonText`改成`SPELLS`

在`Event Construct`里`SpellMenuButton`的`Get Button`的`Assign On Clicked`->`Add Custom Event`命名为`SpellMenuButtonClicked`

`SpellMenuButtonClicked`->`SpellMenuButton`的`Get Button`的`Set Is Ebabled`为false->`Get Player Controller`的`Create Widget`选择` WBP_SpellMenu`->`Add to Viewport`->`Set Position in Viewport`,X坐标用`Get Viewport Size`的Break的X-`Create Widget`返回值的`GetSizeBoxRoot`的`GetWidthOverride`+`MenuPadding`；Y坐标用`MenuPadding`->`SpellMenuButton`的`Assign Spell Menu Closed`->`SpellMenuButton`的`Get Button`的`Set Is Ebabled`为true

![1711714441527](E:\Typora\TyporaPic\1711714441527.png)



## 打开AttributeMenu和SpellMenu的时候禁止鼠标的射线检测

### 在`WBP_Overlay`里处理

加两个bool类型的变量命名为`AttributeMenuOpen`和`SpellMenuOpen`，默认都为false

当`XXXMenuButtonClicked`的时候设置为true，`XXXMenuClosed_Event`的时候设置回false

`XXXMenuButtonClicked`的最后->`Get Player Controller`的`Set Input Mode UI Only`

`XXXMenuClosed_Event`的最后判断下另一个bool是否也是false，如果也是false的话->`Get Player Controller`的`Set Input Mode Game And UI`并取消勾选`Hide Cursor During Capture`



![1711714425114](E:\Typora\TyporaPic\1711714425114.png)



![1711714431777](E:\Typora\TyporaPic\1711714431777.png)





# Spell Menu Widget Controller

## 技能菜单的WidgetController

### 创建` SpellMenuWidgetController`

放在` Aura\Public\UI\WidgetController`下

继承自` AuraWidgetController`

不用执行父类的内容，自己处理自己的

```cpp
public:
	virtual void BroadcastInitialValues() override;
	virtual void BindCallbacksToDependencies() override;
```



```cpp
void USpellMenuWidgetController::BroadcastInitialValues()
{
	
}

void USpellMenuWidgetController::BindCallbacksToDependencies()
{
	
}
```



### 在` AuraWidgetController`里处理

把之前放在` OverlayWidgetController`的Ability相关的内容挪回来，方便共用

原本存的引擎类的对象加个函数转换成Aura相关的类

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FAbilityInfoSignature, const FAuraAbilityInfo&, Info);

public:
	UPROPERTY(BlueprintAssignable, Category="GAS|Messages")
	FAbilityInfoSignature AbilityInfoDelegate;

	void BroadcastAbilityInfo();

protected:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Widget Data")
	TObjectPtr<UAbilityInfo> AbilityInfo;

	UPROPERTY(BlueprintReadOnly, Category="WidgetController")
	TObjectPtr<AAuraPlayerController> AuraPlayerController;

	UPROPERTY(BlueprintReadOnly, Category="WidgetController")
	TObjectPtr<AAuraPlayerState> AuraPlayerState;

	UPROPERTY(BlueprintReadOnly, Category="WidgetController")
	TObjectPtr<UAuraAbilitySystemComponent> AuraAbilitySystemComponent;

	UPROPERTY(BlueprintReadOnly, Category="WidgetController")
	TObjectPtr<UAuraAttributeSet> AuraAttributeSet;

	AAuraPlayerController* GetAuraPC();
	AAuraPlayerState* GetAuraPS();
	UAuraAbilitySystemComponent* GetAuraASC();
	UAuraAttributeSet* GetAuraAS();
```



```cpp
#include "Player/AuraPlayerController.h"
#include "Player/AuraPlayerState.h"
#include "AbilitySystem/AuraAbilitySystemComponent.h"
#include "AbilitySystem/AuraAttributeSet.h"
#include "AbilitySystem/Data/AbilityInfo.h"

void UAuraWidgetController::BroadcastAbilityInfo()
{
    if (!GetAuraASC()->bStartupAbilitiesGiven) return;

	FForEachAbility BroadcastDelegate;
	BroadcastDelegate.BindLambda([this](const FGameplayAbilitySpec& AbilitySpec)
	{
		FAuraAbilityInfo Info = AbilityInfo->FindAbilityInfoForTag(GetAuraASC()->GetAbilityTagFromSpec(AbilitySpec));
		Info.InputTag = GetAuraASC()->GetInputTagFromSpec(AbilitySpec);
		AbilityInfoDelegate.Broadcast(Info);
	});
	GetAuraASC()->ForEachAbility(BroadcastDelegate);
}

AAuraPlayerController* UAuraWidgetController::GetAuraPC()
{
	if (AuraPlayerController == nullptr)
	{
		AuraPlayerController = Cast<AAuraPlayerController>(PlayerController);
	}
	return AuraPlayerController;
}

AAuraPlayerState* UAuraWidgetController::GetAuraPS()
{
	if (AuraPlayerState == nullptr)
	{
		AuraPlayerState = Cast<AAuraPlayerState>(PlayerState);
	}
	return AuraPlayerState;
}

UAuraAbilitySystemComponent* UAuraWidgetController::GetAuraASC()
{
	if (AuraAbilitySystemComponent == nullptr)
	{
		AuraAbilitySystemComponent = Cast<UAuraAbilitySystemComponent>(AbilitySystemComponent);
	}
	return AuraAbilitySystemComponent;
}

UAuraAttributeSet* UAuraWidgetController::GetAuraAS()
{
	if (AuraAttributeSet == nullptr)
	{
		AuraAttributeSet = Cast<UAuraAttributeSet>(AttributeSet);
	}
	return AuraAttributeSet;
}
```



### 在` AuraAbilitySystemComponent`里处理

` AuraWidgetController`有函数拿到ASC了，不需要在委托的绑定里塞上ASC了

```cpp
DECLARE_MULTICAST_DELEGATE(FAbilitiesGiven);
```



```cpp
AbilitiesGivenDelegate.Broadcast();
```



### 在` OverlayWidgetController`里处理

把技能相关的内容挪到` AuraWidgetController`基类里

原本获取PlayerState、ASC等内容改成用基类的函数

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FAbilityInfoSignature, const FAuraAbilityInfo&, Info);

public:
	UPROPERTY(BlueprintAssignable, Category="GAS|Messages")
	FAbilityInfoSignature AbilityInfoDelegate;

protected:
	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly, Category = "Widget Data")
	TObjectPtr<UAbilityInfo> AbilityInfo;

	void OnInitializeStartupAbilities(UAuraAbilitySystemComponent* AuraAbilitySystemComponent);
```



### 在` AttributeMenuWidgetController `里处理

原本获取PlayerState、ASC、AS等内容改成用基类的函数





## 加个装备技能的按钮

### 在`WBP_OffensiveSpellTree`里处理

`BoxHeight`改成300



### 在`WBP_PassiveSpellTree`里处理

`BoxHeight`改成60



### 在`WBP_SpellMenu`处理

加个`WBP_WideButton`放在`WBP_PassiveSpellTree`下命名为`Button_Equip`，`Text`改成`Equip`,`BoxWidth`改成120，`Horizontal Alignment`改成Center，选中`Fill Empty Space`

加两个Spacer在`Button_Equip`之前和之后，Size为(480, 20)





# Constructing the Spell Menu Widget Controller

## 构造技能菜单的WidgetController

### 在` SpellMenuWidgetController`里处理

设置类为蓝图可接受的基类

```cpp
UCLASS(BlueprintType, Blueprintable)
class AURA_API USpellMenuWidgetController : public UAuraWidgetController
```



### 在` AuraHUD`里处理

和前面几个WidgetController类似

```cpp
public:
	USpellMenuWidgetController* GetSpellMenuWidgetController(const FWidgetControllerParams& WCParams);

private:
	UPROPERTY()
	TObjectPtr<USpellMenuWidgetController> SpellMenuWidgetController;

	UPROPERTY(EditAnywhere)
	TSubclassOf<USpellMenuWidgetController> SpellMenuWidgetControllerClass;
```



```cpp
#include "UI/WidgetController/SpellMenuWidgetController.h"

USpellMenuWidgetController* AAuraHUD::GetSpellMenuWidgetController(const FWidgetControllerParams& WCParams)
{
	if (SpellMenuWidgetController == nullptr)
	{
		SpellMenuWidgetController = NewObject<USpellMenuWidgetController>(this, SpellMenuWidgetControllerClass);
		if (SpellMenuWidgetController)
		{
			SpellMenuWidgetController->SetWidgetControllerParams(WCParams);
			SpellMenuWidgetController->BindCallbacksToDependencies();
		}
	}
	return SpellMenuWidgetController;
}
```



### 在` AuraAbilitySystemLibrary`里添加获取函数

加个函数用来封装HUD需要的`FWidgetControllerParams`

把之前的函数内容改一下，meta加个`DefaultToSelf`传入调用者self作为上下文对象

```cpp
public:
	UFUNCTION(BlueprintPure, Category="AuraAbilitySystemLibrary|WidgetController", meta = (DefaultToSelf = "WorldContextObject"))
	static bool MakeWidgetControllerParams(const UObject* WorldContextObject, FWidgetControllerParams& OutWCParams, AAuraHUD*& OutAuraHUD);

	UFUNCTION(BlueprintPure, Category="AuraAbilitySystemLibrary|WidgetController", meta = (DefaultToSelf = "WorldContextObject"))
	static UOverlayWidgetController* GetOverlayWidgetController(const UObject* WorldContextObject);

	UFUNCTION(BlueprintPure, Category="AuraAbilitySystemLibrary|WidgetController", meta = (DefaultToSelf = "WorldContextObject"))
	static UAttributeMenuWidgetController* GetAttributeMenuWidgetController(const UObject* WorldContextObject);

	UFUNCTION(BlueprintPure, Category="AuraAbilitySystemLibrary|WidgetController", meta = (DefaultToSelf = "WorldContextObject"))
	static USpellMenuWidgetController* GetSpellMenuWidgetController(const UObject* WorldContextObject);
```



```cpp
#include "UI/WidgetController/AuraWidgetController.h"


bool UAuraAbilitySystemLibrary::MakeWidgetControllerParams(const UObject* WorldContextObject, FWidgetControllerParams& OutWCParams, AAuraHUD*& OutAuraHUD)
{
	if (APlayerController* PC = UGameplayStatics::GetPlayerController(WorldContextObject, 0))
	{
		OutAuraHUD = Cast<AAuraHUD>(PC->GetHUD());
		if (OutAuraHUD)
		{
			AAuraPlayerState* PS = PC->GetPlayerState<AAuraPlayerState>();
			UAbilitySystemComponent* ASC = PS->GetAbilitySystemComponent();
			UAttributeSet* AS = PS->GetAttributeSet();

			OutWCParams.AttributeSet = AS;
			OutWCParams.AbilitySystemComponent = ASC;
			OutWCParams.PlayerState = PS;
			OutWCParams.PlayerController = PC;
			return true;
		}
	}
	return false;
}

UOverlayWidgetController* UAuraAbilitySystemLibrary::GetOverlayWidgetController(const UObject* WorldContextObject)
{
	FWidgetControllerParams WCParams;
	AAuraHUD* AuraHUD = nullptr;
	if (MakeWidgetControllerParams(WorldContextObject, WCParams, AuraHUD))
	{
		return AuraHUD->GetOverlayWidgetController(WCParams);
	}
	return nullptr;
}

UAttributeMenuWidgetController* UAuraAbilitySystemLibrary::GetAttributeMenuWidgetController(const UObject* WorldContextObject)

{
	FWidgetControllerParams WCParams;
	AAuraHUD* AuraHUD = nullptr;
	if (MakeWidgetControllerParams(WorldContextObject, WCParams, AuraHUD))
	{
		return AuraHUD->GetAttributeMenuWidgetController(WCParams);
	}
	return nullptr;
}

USpellMenuWidgetController* UAuraAbilitySystemLibrary::GetSpellMenuWidgetController(const UObject* WorldContextObject)
{
	FWidgetControllerParams WCParams;
	AAuraHUD* AuraHUD = nullptr;
	if (MakeWidgetControllerParams(WorldContextObject, WCParams, AuraHUD))
	{
		return AuraHUD->GetSpellMenuWidgetController(WCParams);
	}
	return nullptr;
}
```



### 创建` BP_SpellMenuWidgetController`

放在` Content\Blueprints\UI\WidgetController`下

`AbilityInfo`设置一下`DA_AttributeInfo`



### 在` BP_AuraHUD`里配置

`SpellMenuWidgetControllerClass`选` BP_SpellMenuWidgetController`



### 在` WBP_SpellMenu`里设置WidgetController

`Event Construct`加个Sequence

`Get Spell Menu Widget Controller`->`Set Widget Controller`

![1711784982584](E:\Typora\TyporaPic\1711784982584.png)





# Equipped Row Button

## 已装备技能那一行的按钮

### 在` AuraGameplayTags`里给被动技能加上Tag

用来在蓝图里配置每个技能按钮代表哪个技能的

```cpp
public:
	FGameplayTag InputTag_Passive_1;
	FGameplayTag InputTag_Passive_2;
```



```cpp
void FAuraGameplayTags::InitializeNativeGameplayTags()
{
	// ...
    GameplayTags.InputTag_Passive_1 = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("InputTag.Passive.1"),
		FString("Input Tag Passive Ability 1")
	);

	GameplayTags.InputTag_Passive_2 = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("InputTag.Passive.2"),
		FString("Input Tag Passive Ability 2")
	);
}
```



### 在` SpellMenuWidgetController`里处理

初始化的时候向蓝图广播一下Owner已激活的Ability拥有的AbilityInfo

```cpp
void USpellMenuWidgetController::BroadcastInitialValues()
{
	BroadcastAbilityInfo();
}
```



### 创建` WBP_EquippedRow_Button`

放在` Content\Blueprints\UI\SpellGlobes`

复制一份`WBP_SpellGlobeButton`

在`Event Widget Controller Set`的时候删掉`BPOverlayWidgetController`

加个`GameplayTag`类型的变量命名为`InputTag`



`Image Background`和`Image Icon`的`Set Brush`用`TransparentBrush`包裹起来函数命名为`ClearGlobe`

`Event Pre Construct`的时候调用一下`ClearGlobe`

![1711788985004](E:\Typora\TyporaPic\1711788985004.png)



`Event Construct`->`WidgetController`的`Cast to BP_SpellMenuWidgetController`的`Promote to Variable`命名为`BPSpellMenuWidgetController`

之后`BPSpellMenuWidgetController`的`Assign Ability Info Delegate`->Info给Break掉拿到`Info Input Tag`是否和变量`InputTag`相同，如果相同->`Image_Icon`的`Set Brush`用`Icon`->`Image_Background`的`Set Brush`用`Background Material`

![1711788977079](E:\Typora\TyporaPic\1711788977079.png)



### 在` WBP_EquippedSpellRow`里处理

用` WBP_EquippedRow_Button`替换`WBP_SpellGlobeButton`，主动技能的BoxHeight和BoxWidth都是60，Padding为4；被动技能的BoxHeight和BoxWidth都是40，Padding为3.5，顺便给每个都设置为变量命名为`Globe_XXX`



给每个Globe都配置一下`InputTag`，函数命名为`SetGlobeInputTag`



`Event Widget Controller Set`的时候给`Globe_XXX`都设置WidgetController，函数命名为`SetGlobeWidgetController`

![1711788806021](E:\Typora\TyporaPic\1711788806021.png)





### 在`WBP_SpellMenu`里处理

把`WBP_EquippedSpellRow`设置为变量

`Event Widget Controller Set`的时候`Get SpellMenuWidgetController`的`Cast to BP_SpellMenuWidgetController`的`Promote to Variable`命名为`BPSpellMenuWidgetController`->`SetWidgetController`

然后`WBP_EquippedSpellRow`的`SetWidgetController`

然后`BPSpellMenuWidgetController`的`Broadcast Initial Values`

![1711788715903](E:\Typora\TyporaPic\1711788715903.png)





# Ability Status and Type

## 技能的选取状态和所属类型

```
Ability Status
	Locked
	Eligible
	Unlocked
	Equipped
	
Ability Status Tag
	Abilities.Status.Locked
	Abilities.Status.Eligible
	Abilities.Status.Unlocked
	Abilities.Status.Equipped
	
Ability Type Tag
	Abilities.Type.Offensive
	Abilities.Type.Passive
	Abilities.Type.None
```



### 在` AuraGameplayTags`里处理

顺便把之前给怪物用的HitReact也改成Ability



```cpp
public:
	FGameplayTag Abilities_HitReact;

	FGameplayTag Abilities_Status_Locked;
	FGameplayTag Abilities_Status_Eligible;
	FGameplayTag Abilities_Status_Unlocked;
	FGameplayTag Abilities_Status_Equipped;

	FGameplayTag Abilities_Type_Offensive;
	FGameplayTag Abilities_Type_Passive;
	FGameplayTag Abilities_Type_None;
```



```cpp
void FAuraGameplayTags::InitializeNativeGameplayTags()
{
    // ...
    GameplayTags.Abilities_HitReact = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Abilities.HitReact"),
		FString("Hit React Ability")
	);
    
    GameplayTags.Abilities_Status_Eligible = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Abilities.Status.Eligible"),
		FString("Eligible Status")
	);

	GameplayTags.Abilities_Status_Equipped = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Abilities.Status.Equipped"),
		FString("Equipped Status")
	);

	GameplayTags.Abilities_Status_Locked = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Abilities.Status.Locked"),
		FString("Locked Status")
	);

	GameplayTags.Abilities_Status_Unlocked = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Abilities.Status.Unlocked"),
		FString("Unlocked Status")
	);

	GameplayTags.Abilities_Type_None = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Abilities.Type.None"),
		FString("Type None")
	);

	GameplayTags.Abilities_Type_Offensive = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Abilities.Type.Offensive"),
		FString("Type Offensive")
	);

	GameplayTags.Abilities_Type_Passive = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Abilities.Type.Passive"),
		FString("Type Passive")
	);
}
```



### 在` AuraAbilitySystemComponent`里处理

在`AbilitySpec.DynamicAbilityTags`里添加Tag

加个函数从`AbilitySpec.DynamicAbilityTags`拿到`Abilities.Status`的GameplayTag

```cpp
public:
	static FGameplayTag GetStatusFromSpec(const FGameplayAbilitySpec& AbilitySpec);
```



```cpp
#include "AuraGameplayTags.h"

void UAuraAbilitySystemComponent::AddCharacterAbilities(const TArray<TSubclassOf<UGameplayAbility>>& StartupAbilities)
{
    // ...
    AbilitySpec.DynamicAbilityTags.AddTag(FAuraGameplayTags::Get().Abilities_Status_Equipped);
}

FGameplayTag UAuraAbilitySystemComponent::GetStatusFromSpec(const FGameplayAbilitySpec& AbilitySpec)
{
    for(FGameplayTag StatusTag : AbilitySpec.DynamicAbilityTags)
    {
        if(StatusTag.MatchesTag(FGameplayTag::RequestGameplayTag(FName("Abilities.Status"))))
        {
            return StatusTag;
        }
    }
    
    return FGameplayTag();
}
```





# Showing Abilities in the Spell Tree

## 在技能树中显示技能

### 在` AbilityInfo`里处理

在存储的结构体里加个变量存一下Status

```cpp
struct FAuraAbilityInfo
{
	// ...
    UPROPERTY(BlueprintReadOnly)
	FGameplayTag StatusTag = FGameplayTag();
};
```



### 在` AuraWidgetController`里处理

广播可激活的技能的时候把Status也加上

```cpp
void UAuraWidgetController::BroadcastAbilityInfo()
{
	// ...
    Info.StatusTag = AuraAbilitySystemComponent->GetStatusFromSpec(AbilitySpec);
}
```



### 在` WBP_SpellGlobe_Button`里处理

加个`GameplayTag`类型的变量命名为`AbilityTag`并设置为其他蓝图可见可编辑

修改`Event Widget Controller Set`，把`OverlayWidgetController`的内容都删了

 `Event Widget Controller Set`的Sequence的开头->`WidgetController`的`Cast to BP_SpellMenuWidgetController`的`Promote to Variable`命名为`BPSpellMenuWidgetController`

然后`BPSpellMenuWidgetController`的`Assign Ability Info Delegate`把Info给Break掉

![1711794774731](E:\Typora\TyporaPic\1711794774731.png)

`StatusTag`给`Promote to Variable`命名为`Status`，`Icon`给`Promote to Variable`命名为`AbilityIcon`，`BackgroundMaterial`给`Promote to Variable`命名为`AbilityBackground`->`AbilityTag`和`AbilityTag`的`MatchesTag`选择Exact为true->

`Status`和`Abilities.Status.Locked`的`MatchesTag`选择Exact为true->`Image Icon`的`Set Brush from Texture`选择`Locked_sm`->`Image Background`的`Set Brush from Material`选择`MI_LockedBG`，添加一个函数命名为`SetGlobeLocked`

否则`Status`和`Abilities.Status.Equipped`的`MatchesTag`选择Exact为true `OR` `Abilities.Status.Unlocked`的`MatchesTag`选择Exact为true->`Image Icon`的`Set Brush from Texture`选择`AbilityIcon`->`Image Background`的`Set Brush from Material`选择`AbilityBackground`，添加一个函数命名为`SetGlobeEquippedOrUnlocked`

否则`Status`和`Abilities.Status.Eligible`的`MatchesTag`选择Exact为true->`Image Icon`的`Set Brush from Texture`选择`AbilityIcon`->`Image Background`的`Set Brush from Material`选择`MI_LockedBG`，添加一个函数命名为`SetGlobeEligible`

![1711794754253](E:\Typora\TyporaPic\1711794754253.png)



![1711794747452](E:\Typora\TyporaPic\1711794747452.png)



### 在` WBP_OffensiveSpellTree`里处理

左下角的` WBP_SpellGlobe_Button`的`AbilityTag`设置为`Abilities.Fire.FireBolt`

![1711794878710](E:\Typora\TyporaPic\1711794878710.png)



`Event Widget Controller Set`->`WidgetController`的`Cast to BP_SpellMenuWidgetController`的`Promote to Variable`命名为`BPSpellMenuWidgetController`->每个`WBP_SpellGlobe_Button`都`SetWidgetController`

![1711794861145](E:\Typora\TyporaPic\1711794861145.png)

![1711794872773](E:\Typora\TyporaPic\1711794872773.png)



### 在` WBP_SpellMenu`里处理

在`SetSubwidget WidgetController`里给` WBP_OffensiveSpellTree`和`WBP_PassiveSpellTree`设置`SpellMenuWidgetController`

![1711794889149](E:\Typora\TyporaPic\1711794889149.png)



## 修一下`SetInputMode_GameAndUI`的报错

如果开着Menu关闭游戏就会报这个错，原因是PlayerController在Widget之前被销毁了

### 在`WBP_Overlay`里处理

`Get Player Controller`->`Is Valid`为true->`SetInputModeGameAndUI`

![1711792906844](E:\Typora\TyporaPic\1711792906844.png)





# Ability Level Requirement

## 学习技能的玩家等级要求

在` AbilityInfo`里处理

加个等级，再加个是哪个技能

```cpp
struct FAuraAbilityInfo
{
    // ...
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	int32 LevelRequirement = 1;

	UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	TSubclassOf<UGameplayAbility> Ability;
}
```



### 在` AuraGameModeBase`里处理

找个ServerOnly的地方存一下整个DataAsset

```cpp
public:
	UPROPERTY(EditDefaultsOnly, Category = "Ability Info")
	TObjectPtr<UAbilityInfo> AbilityInfo;
```



### 在` AuraAbilitySystemLibrary`里处理

```cpp
public:
	UFUNCTION(BlueprintCallable, Category="AuraAbilitySystemLibrary|CharacterClassDefaults")
	static UAbilityInfo* GetAbilityInfo(const UObject* WorldContextObject);
```



```cpp
UAbilityInfo* UAuraAbilitySystemLibrary::GetAbilityInfo(const UObject* WorldContextObject)
{
	const AAuraGameModeBase* AuraGameMode = Cast<AAuraGameModeBase>(UGameplayStatics::GetGameMode(WorldContextObject));
	if (AuraGameMode)
	{
		return AuraGameMode->AbilityInfo;
	}

	return nullptr;
}
```



### 在`DA_AbilityInfo`里配置

FireBolt的`LevelRequirement`为1，`Ability`为`GA_FireBolt`



### 在` BP_AuraGameMode`里配置

AbilityInfo选择`DA_AbilityInfo`



## 加个新的雷击技能暂时做测试用

### 在` AuraGameplayTags`里处理

```cpp
public:
	FGameplayTag Abilities_Lightning_Electrocute;
```



```cpp
void FAuraGameplayTags::InitializeNativeGameplayTags()
{
	// ...
    GameplayTags.Abilities_Lightning_Electrocute = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Abilities.Lightning.Electrocute"),
		FString("Electrocute Ability Tag")
	);
}
```



### 添加` GA_Electrocute`

放在` Content\Blueprints\AbilitySystem\Aura\Abilities\Lightning`下

继承自`AuraGameplayAbility`

目前只是Print String即可

`Ability Tags`选择`Abilities.Lightning.Electrocute`



### 在`DA_AbilityInfo`里配置

`Ability Tags`选择`Abilities.Lightning.Electrocute`

`Icon`选择`Shock`

`BackgroundMaterial`选择`MI_ShockSkillBG`

`Level Requirement`设置为2

`Ability`选择` GA_Electrocute`



### 在`WBP_OffensiveSpellTree`里处理

中间那竖排最下方一个的`Ability Tags`选择`Abilities.Lightning.Electrocute`

![1711796606890](E:\Typora\TyporaPic\1711796606890.png)





# Update Ability Statuses

## 更新技能的Status

### 在` AuraAbilitySystemComponent`里处理

遍历AbilityInfo，对于每个Ability，先检查一下是否满足等级要求，然后通过检查是否是ASC的某个已激活的Abilities的AbilityTags来决定要不要把这个Ability激活

用`MarkAbilitySpecDirty`来强制同步Replicated给客户端

```cpp
public:
	FGameplayAbilitySpec* GetSpecFromAbilityTag(const FGameplayTag& AbilityTag);

	void UpdateAbilityStatuses(int32 Level);
```



```cpp
#include "AbilitySystem/AuraAbilitySystemLibrary.h"
#include "AbilitySystem/Data/AbilityInfo.h"

FGameplayAbilitySpec* UAuraAbilitySystemComponent::GetSpecFromAbilityTag(const FGameplayTag& AbilityTag)
{
    FScopedAbilityListLock ActiveScopeLoc(*this);
    for(FGameplayAbilitySpec& AbilitySpec : GetActivatableAbilities())
    {
        for(FGameplayTag Tag : AbilitySpec.Ability.Get()->AbilityTags)
        {
            if(Tag.MatchesTag(AbilityTag))
            {
                return &AbilitySpec;
            }
        }
    }
    
    return nullptr;
}

void UAuraAbilitySystemComponent::UpdateAbilityStatuses(int32 Level)
{
    UAbilityInfo* AbilityInfo = UAuraAbilitySystemLibrary::GetAbilityInfo(GetAvatarActor());
    for(const FAuraAbilityInfo& Info : AbilityInfo->AbilityInformation)
    {
        if (!Info.AbilityTag.IsValid()) 
        {
            continue;
        }
        
		if (Level < Info.LevelRequirement) 
        {
            continue;
        }
        
        if(GetSpecFromAbilityTag(Info.AbilityTag) == nullptr)
        {
            FGameplayAbilitySpec AbilitySpec = FGameplayAbilitySpec(Info.Ability, 1);
            AbilitySpec.DynamicAbilityTags.AddTag(FAuraGameplayTags::Get().Abilities_Status_Eligible);
            GiveAbility(AbilitySpec);
            MarkAbilitySpecDirty(AbilitySpec);
        }
    }
}
```





# Updating Status in the Spell Menu

## 在SpellMenu里更新技能的Status

### 在` AuraAbilitySystemComponent`里处理

加个Delegate用于向蓝图更新Status

```cpp
DECLARE_MULTICAST_DELEGATE_TwoParams(FAbilityStatusChanged, const FGameplayTag& /*AbilityTag*/, const FGameplayTag& /*StatusTag*/)
    
public:
	FAbilityStatusChanged AbilityStatusChanged;

protected:
	UFUNCTION(Client, Reliable)
	void ClientUpdateAbilityStatus(const FGameplayTag& AbilityTag, const FGameplayTag& StatusTag);
```



```cpp
void UAuraAbilitySystemComponent::UpdateAbilityStatuses(int32 Level)
{
    // ...
    ClientUpdateAbilityStatus(Info.AbilityTag, FAuraGameplayTags::Get().Abilities_Status_Eligible);
}

void UAuraAbilitySystemComponent::ClientUpdateAbilityStatus_Implementation(const FGameplayTag& AbilityTag, const FGameplayTag& StatusTag)
{
	AbilityStatusChanged.Broadcast(AbilityTag, StatusTag);
}
```



### 在` AuraCharacter`里处理

作为`UpdateAbilityStatuses`的触发点

```cpp
void AAuraCharacter::AddToPlayerLevel_Implementation(int32 InPlayerLevel)
{
	// ...
    if (UAuraAbilitySystemComponent* AuraASC = Cast<UAuraAbilitySystemComponent>(GetAbilitySystemComponent()))
	{
		AuraASC->UpdateAbilityStatuses(AuraPlayerState->GetPlayerLevel());
	}
}
```



### 在` SpellMenuWidgetController`里处理委托的绑定

```cpp
#include "AbilitySystem/AuraAbilitySystemComponent.h"
#include "AbilitySystem/Data/AbilityInfo.h"

void USpellMenuWidgetController::BindCallbacksToDependencies()
{
	GetAuraASC()->AbilityStatusChanged.AddLambda([this](const FGameplayTag& AbilityTag, const FGameplayTag& StatusTag)
	{
		if (AbilityInfo)
		{
			FAuraAbilityInfo Info = AbilityInfo->FindAbilityInfoForTag(AbilityTag);
			Info.StatusTag = StatusTag;
			AbilityInfoDelegate.Broadcast(Info);
		}
	});
}
```





# Show Spell Points

## 显示技能点

### 在`SpellMenuWidgetController`里处理

```cpp
public:
	UPROPERTY(BlueprintAssignable)
	FOnPlayerStatChangedSignature SpellPointsChanged;
```



```cpp
#include "Player/AuraPlayerState.h"

void USpellMenuWidgetController::BroadcastInitialValues()
{
    // ...
    SpellPointsChanged.Broadcast(GetAuraPS()->GetSpellPoints());
}

void USpellMenuWidgetController::BindCallbacksToDependencies()
{
    // ...
    GetAuraPS()->OnSpellPointsChangedDelegate.AddLambda(
    	[this](int32 SpellPoints)
        {
            SpellPointsChanged.Broadcast(SpellPoints);
        }
    );
}
```



### 在` WBP_SpellMenu`里处理

给`WBP_FramedValue`改个名`FramedValue_SpellPoints`设置为变量

在`Broadcast Initial Values`之前`BPSpellMenuWidgetController`的`Assign SpellPointsChanged`->`FramedValue_SpellPoints`的`Get TextBlockValue`的`Set Text`





# Selecting Icons

## 选择某个技能

记得要在选中某个技能的时候取消选中其他技能

### 在` WBP_SpellGlobe_Button`里处理

把`Image_Selection`设置为变量

把`Button_Ring`设置为变量

创建一个函数命名为`Select`->`Image_Selection`的`Set Render Opactity`设置为1->`Select Animation`的`Play Animation`->`Play Sound 2D`选择`SFX_UI_ButtonClick_04`

![1711799692849](E:\Typora\TyporaPic\1711799692849.png)

创建一个函数命名为`DeSelect`->`Image_Selection`的`Set Render Opactity`设置为0

![1711800084363](E:\Typora\TyporaPic\1711800084363.png)

加个`Event Dispatchers`命名为`SpellGlobeSelected`，添加一个`WBP_SpellGlobeButton`类型的输入命名为`SelectedGlobe`

给`Button_Ring`添加`OnClicked`事件->`SpellGlobeSelected`参数用self

![1711800094009](E:\Typora\TyporaPic\1711800094009.png)



### 在` WBP_OffensiveSpellTree`里处理

在`Event Construct`->给所有的SpellGlobe的`Assign OnSpellGlobeSelected`->所有的SpellGlobe调用`DeSelect`->`SelectedGlobe`调用`Select`

![1711800052258](E:\Typora\TyporaPic\1711800052258.png)



### 在` WBP_PassiveSpellTree`里处理

在`Event Construct`->给所有的SpellGlobe的`Assign OnSpellGlobeSelected`->所有的SpellGlobe调用`DeSelect`->`SelectedGlobe`调用`Select`

![1711800059935](E:\Typora\TyporaPic\1711800059935.png)





# Deselecting Icons

## 选中任意一个技能的时候取消选中其他所有的技能，包括不同类型的(主动/被动)

### 在`WBP_OffensiveSpellTree`里处理

加个`Event Dispatchers`命名为`OnOffensiveSpellGlobeSelected`

`Select`->`OnOffensiveSpellGlobeSelected`

加个函数命名为`DeselectAll`，把所有的`SpellGlobe`都执行`DeSelect`



### 在`WBP_PassiveSpellTree`里处理

加个`Event Dispatchers`命名为`OnPassiveSpellGlobeSelected`

`Select`->`OnPassiveSpellGlobeSelected`

加个函数命名为`DeSelectAll`，把所有的`SpellGlobe`都执行`DeSelect`



### 在`WBP_SpellMenu`里处理

在`Bind Event to On Clicked`之后->`WBP_OffensiveSpellTree`的`Assign OnOffensiveSpellGlobeSelected`->`WBP_PassiveSpellTree`的`Assign OnPassiveSpellGlobeSelected`

执行的内容就是另一个SpellTree执行`DeSelectAll`





# Spell Menu Buttons

## 处理SpellMenu的Button

初始打开Menu的时候都禁用，选中某个Unlocked/Equipped的技能的时候启用两个按钮，选中某个Eligible的时候只解锁`Spend Point`，选中某个Locked的时候都禁用

除此以外还要考虑一下是否有技能点，如果没有技能点的话`Spend Point`一直是禁用状态



### 在` AuraGameplayTags`里处理

加个`Abilities.None`当SpellMenu里还没配置技能的那些Globe的AbilityTag的默认值

```cpp
public:
	FGameplayTag Abilities_None;
```



```cpp
void FAuraGameplayTags::InitializeNativeGameplayTags()
{
    // ...
    GameplayTags.Abilities_None = UGameplayTagsManager::Get().AddNativeGameplayTag(
		FName("Abilities.None"),
		FString("No Ability - like the nullptr for Ability Tags")
	);
}
```



### 在` SpellMenuWidgetController`里处理

加个委托，当蓝图调用函数通知选中某个技能的时候广播通知蓝图两个Button的状况

```cpp
#include "AuraGameplayTags.h"
#include "GameplayTagContainer.h"

DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FSpellGlobeSelectedSignature, bool, bSpendPointsButtonEnabled, bool, bEquipButtonEnabled);

public:
	UPROPERTY(BlueprintAssignable)
	FSpellGlobeSelectedSignature SpellGlobeSelectedDelegate;

	UFUNCTION(BlueprintCallable)
	void SpellGlobeSelected(const FGameplayTag& AbilityTag);

private:
	
	static void ShouldEnableButtons(const FGameplayTag& AbilityStatus, int32 SpellPoints, bool& bShouldEnableSpellPointsButton, bool& bShouldEnableEquipButton);
```



```cpp
void USpellMenuWidgetController::SpellGlobeSelected(const FGameplayTag& AbilityTag)
{
    const FAuraGameplayTags GameplayTags = FAuraGameplayTags::Get();	
    const int32 SpellPoints = GetAuraPS()->GetSpellPoints();
    FGameplayTag AbilityStatus;
    bool bTagVaild = AbilityTag.IsValid();
    bool bTagNone = AbilityTag.MatchesTag(GameplayTags.Abilities_None);
    const FGameplayAbilitySpec* AbilitySpec = GetAuraASC()->GetSpecFromAbilityTag(AbilityTag);
    bool bSpecVaild = AbilitySpec != nullptr;
    if(!bTagVaild || bTagNone || !bSpecVaild)
    {
        AbilityStatus = GameplayTags.Abilities_Status_Locked;
    }
    else
    {
        AbilityStatus = GetAuraASC()->GetStatusFromSpec(*AbilitySpec);
    }
    
    bool bEnableSpendPoints = false;
	bool bEnableEquip = false;
	ShouldEnableButtons(AbilityStatus, SpellPoints, bEnableSpendPoints, bEnableEquip);
	SpellGlobeSelectedDelegate.Broadcast(bEnableSpendPoints, bEnableEquip);
}

void USpellMenuWidgetController::ShouldEnableButtons(const FGameplayTag& AbilityStatus, int32 SpellPoints, bool& bShouldEnableSpellPointsButton, bool& bShouldEnableEquipButton)
{
    const FAuraGameplayTags GameplayTags = FAuraGameplayTags::Get();
    bShouldEnableSpellPointsButton = false;
	bShouldEnableEquipButton = false;
    if(AbilityStatus.MatchesTagExact(GameplayTags.Abilities_Status_Equipped) || AbilityStatus.MatchesTagExact(GameplayTags.Abilities_Status_Unlocked))
    {
        bShouldEnableEquipButton = true;
        if(SpellPoints > 0)
        {
            bShouldEnableSpellPointsButton = true;
        }
    }
    else if(AbilityStatus.MatchesTagExact(GameplayTags.Abilities_Status_Eligible))
    {
        if(SpellPoints > 0)
        {
            bShouldEnableSpellPointsButton = true;
        }
    }
}
```



### 在` AuraPlayerState`里处理

初始的时候技能点数为0

```cpp
private:
	int32 SpellPoints = 0;
```



### 在` WBP_SpellGlobe_Button`里处理

`OnClicked`->`BPSpellMenuWidgetController`的`SpellGlobeSelected`

`Ability Tag`设置个默认值`Abilities.None`

![1711858022659](E:\Typora\TyporaPic\1711858022659.png)



### 在`WBP_PassiveSpellTree`里处理

绑定一下WidgetController

![1711858014747](E:\Typora\TyporaPic\1711858014747.png)



### 在` WBP_SpellMenu`里处理

`Event Pre Construct`的时候->`Button_SpendPoint`和`Button_Equip`的`Set Is Enabled`为false

在`Set Spell Menu Widget Controller`之后->`BPSpellMenuWidgetController`的`Assign SpellGlobeSelectedDelegate`->`Button_SpendPoint`和`Button_Equip`的`Set Is Enabled`对应值



![1711858042631](E:\Typora\TyporaPic\1711858042631.png)

![1711858047724](E:\Typora\TyporaPic\1711858047724.png)





# Selected Ability

## 选中的技能

处理选中某个技能的时候正好升级了的边界情况问题

当技能点数变化以及技能状态变化的时候要更新并广播一下俩按钮的delegate，

### 在` SpellMenuWidgetController`里处理

技能点数变化以及技能状态变化分别是PlayerState和ASC处理的，无法确定执行的先后性，比如先收到升级带来的技能点数的变化，后收到升级带来的技能的Status变化

在选中某个技能的时候存一下他当时的状况，在收到status变更的时候判断下是不是正选中的那个技能，是的话就更新一下值，收到技能点数变更的时候更新一下

不管是收到status变更还是技能点数变更都更新并广播一次两个按钮的情况，值用本地存的

```cpp
struct FSelectedAbility
{
	FGameplayTag Ability = FGameplayTag();
	FGameplayTag Status = FGameplayTag();
};

private:
	FSelectedAbility SelectedAbility = { FAuraGameplayTags::Get().Abilities_None,  FAuraGameplayTags::Get().Abilities_Status_Locked };
	int32 CurrentSpellPoints = 0;
```



```cpp
void USpellMenuWidgetController::BindCallbacksToDependencies()
{
    // ...
    GetAuraASC()->AbilityStatusChanged.AddLambda([this](const FGameplayTag& AbilityTag, const FGameplayTag& StatusTag)
    {
        if (SelectedAbility.Ability.MatchesTagExact(AbilityTag))
        {
            SelectedAbility.Status = StatusTag;
            bool bEnableSpendPoints = false;
            bool bEnableEquip = false;
            ShouldEnableButtons(StatusTag, CurrentSpellPoints, bEnableSpendPoints, bEnableEquip);
            SpellGlobeSelectedDelegate.Broadcast(bEnableSpendPoints, bEnableEquip);
        }

        if (AbilityInfo)
        {
            // ...
        }
    }
                                                 
    GetAuraPS()->OnSpellPointsChangedDelegate.AddLambda([this](int32 SpellPoints)
    {
        SpellPointsChanged.Broadcast(SpellPoints);
		CurrentSpellPoints = SpellPoints;

		bool bEnableSpendPoints = false;
		bool bEnableEquip = false;
		ShouldEnableButtons(SelectedAbility.Status, CurrentSpellPoints, bEnableSpendPoints, bEnableEquip);
		SpellGlobeSelectedDelegate.Broadcast(bEnableSpendPoints, bEnableEquip);
    }                                             
}
                                                        
void USpellMenuWidgetController::SpellGlobeSelected(const FGameplayTag& AbilityTag)
{
    // ...
    SelectedAbility.Ability = AbilityTag;
	SelectedAbility.Status = AbilityStatus;
}
```





# Spending Spell Points

## 使用技能点解锁技能或升级

### 在` SpellMenuWidgetController`里处理

根据选中的技能来处理

```cpp
public:
	UFUNCTION(BlueprintCallable)
	void SpendPointButtonPressed();
```



```cpp
void USpellMenuWidgetController::BindCallbacksToDependencies()
{
    // ...
    GetAuraASC()->AbilityStatusChanged.AddLambda([this](const FGameplayTag& AbilityTag, const FGameplayTag& StatusTag, int32 NewLevel)
    {
        
    }
}
                                                 
void USpellMenuWidgetController::SpendPointButtonPressed()
{
	if (GetAuraASC())
	{
		GetAuraASC()->ServerSpendSpellPoint(SelectedAbility.Ability);
	}
}
```



### 在` AuraAbilitySystemComponent`里处理

把之前技能status变更的时候广播的委托加个技能等级的变量

加个ServerRPC来处理消耗技能点

```cpp
DECLARE_MULTICAST_DELEGATE_ThreeParams(FAbilityStatusChanged, const FGameplayTag& /*AbilityTag*/, const FGameplayTag& /*StatusTag*/, int32 /*AbilityLevel*/);

public:
	UFUNCTION(Server, Reliable)
	void ServerSpendSpellPoint(const FGameplayTag& AbilityTag);

protected:
	void ClientUpdateAbilityStatus(const FGameplayTag& AbilityTag, const FGameplayTag& StatusTag, int32 AbilityLevel);
```



```cpp
void UAuraAbilitySystemComponent::UpdateAbilityStatuses(int32 Level)
{
    // ...
    ClientUpdateAbilityStatus(Info.AbilityTag,FAuraGameplayTags::Get().Abilities_Status_Eligible, 1);
}

void UAuraAbilitySystemComponent::ClientUpdateAbilityStatus_Implementation(const FGameplayTag& AbilityTag, const FGameplayTag& StatusTag, int32 AbilityLevel)
{
	AbilityStatusChanged.Broadcast(AbilityTag, StatusTag, AbilityLevel);
}

void UAuraAbilitySystemComponent::ServerSpendSpellPoint_Implementation(const FGameplayTag& AbilityTag)
{
    if(FGameplayAbilitySpec* AbilitySpec = GetSpecFromAbilityTag(AbilityTag))
    {
        const FAuraGameplayTags GameplayTags = FAuraGameplayTags::Get();
        FGameplayTag Status = GetStatusFromSpec(*AbilitySpec);
        
        if(GetAvatarActor()->Implements<UPlayerInterface>())
        {
            IPlayerInterface::Execute_AddToSpellPoints(GetAvatarActor(), -1);
        }
        if(Status.MatchesTagExact(GameplayTags.Attributes_Status_Eligible))
        {
            AbilitySpec.DynamicAbilityTags.RemoveTag(GameplayTags.Abilities_Status_Eligible);
            AbilitySpec.DynamicAbilityTags.AddTag(GameplayTags.Abilities_Status_Unlocked));
            Status = GameplayTags.Abilities_Status_Unlocked;
        }
        else if(Status.MatchesTagExact(GameplayTags.Abilities_Status_Equipped) || Status.MatchesTagExact(GameplayTags.Abilities_Status_Unlocked))
        {
            AbilitySpec->Level += 1;
        }
        
        ClientUpdateAbilityStatus(AbilityTag, Status, AbilitySpec->Level);
        MarkAbilitySpecDirty(*AbilitySpec);
    }
}
```



### 在` WBP_SpellMenu`里处理

`Event ConStruct`的地方在`Set Widget Controller`之后->`ButtonSpendPoint`的`GetButton`的`Assign On Clicked`->`BPSpellMenuWidgetController`的`SpendPointButtonPressed`



### 在`CT_Damage`里配置一下技能等级和伤害

`Abilities.FireBolt`





# Rich Text Blocks

## 富文本框

### 创建` DT_RichTextStyle`

放在` Content\Blueprints\UI\Data`下

右击选择`Miscellaneous`->`Data Table`选择`RichTextStyleRow`

#### `Add Row`命名为`Default`

##### `Font`

Font Family选择Amarante

Size选择16

Outline Size填1

##### `Color`

选择(1,1,1,1)



#### `Add Row`命名为`Damage`

##### `Font`

Font Family选择Amarante

Size选择16

Outline Size填1

##### `Color`

选择(0.83,0, 0.06,1)



#### `Add Row`命名为`Percent`

##### `Font`

Font Family选择Amarante

Size选择14

Outline Size填1

##### `Color`

选择(1,0.52, 0.31,1)



#### `Add Row`命名为`Time`

##### `Font`

Font Family选择Amarante

Size选择14

Outline Size填1

##### `Color`

选择(0.15,1,0.23,1)



#### `Add Row`命名为`ManaCost`

##### `Font`

Font Family选择Amarante

Size选择14

Outline Size填1

##### `Color`

选择(0.1,0.84,1,1)



#### `Add Row`命名为`Level`

##### `Font`

Font Family选择Amarante

Size选择14

Outline Size填1

##### `Color`

选择(0.02,1,0.86,1)



#### `Add Row`命名为`Cooldown`

##### `Font`

Font Family选择Amarante

Size选择14

Outline Size填1

##### `Color`

选择(0.47,0.17,1,1)



#### `Add Row`命名为`Title`

##### `Font`

Font Family选择PirataOne

Size选择22

Outline Size填1

##### `Color`

选择(1, 0.57, 0.23,1)



#### `Add Row`命名为`Small`

##### `Font`

Font Family选择DavidLibre-Regular

Size选择14

Outline Size填1

##### `Color`

选择(1,1,1,1)



### 在` WBP_SpellMenu`里处理

`ScrollBox_CurrentLevel`里添加`Rich Text Block`命名为`RichText_CurrentLevel`设置为变量，Padding填12，`TextStyleSet`选择` DT_RichTextStyle`，`Text`填`<Default>Causes </><ManaCost>30</><Default> Mana</>`

`ScrollBox_NextLevel`里添加`Rich Text Block`命名为`RichText_NextLevel`设置为变量，Padding填12，`TextStyleSet`选择` DT_RichTextStyle`





# Spell Descriptions

## 技能描述

先写死在代码里，后面挪到配置表里

### 在` AuraGameplayAbility`里处理

每个技能有三个描述，当前等级，下一等级，以及没解锁的时候的

```cpp
public:
	virtual FString GetDescription(int32 Level);
	virtual FString GetNextLevelDescription(int32 Level);
	static FString GetLockedDescription(int32 Level);
```



`L""`字面值

```cpp
FString UAuraGameplayAbility::GetDescription(int32 Level)
{
	return FString::Printf(TEXT("<Default>%s, </><Level>%d</>"), L"Default Ability Name - LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum LoremIpsum", Level);
}

FString UAuraGameplayAbility::GetNextLevelDescription(int32 Level)
{
	return FString::Printf(TEXT("<Default>Next Level: </><Level>%d</> \n<Default>Causes much more damage. </>"), Level);
}

FString UAuraGameplayAbility::GetLockedDescription(int32 Level)
{
	return FString::Printf(TEXT("<Default>Spell Locked Until Level: %d</>"), Level);
}
```



### 在` AuraAbilitySystemComponent`里处理

加个函数根据AbilityTag获取这个技能的描述

Level从AbilitySpec里拿

```cpp
public:
	bool GetDescriptionsByAbilityTag(const FGameplayTag& AbilityTag, FString& OutDescription, FString& OutNextLevelDescription);
```



```cpp
bool UAuraAbilitySystemComponent::GetDescriptionsByAbilityTag(const FGameplayTag& AbilityTag, FString& OutDescription,FString& OutNextLevelDescription)
{
	if (const FGameplayAbilitySpec* AbilitySpec = GetSpecFromAbilityTag(AbilityTag))
	{
		if(UAuraGameplayAbility* AuraAbility = Cast<UAuraGameplayAbility>(AbilitySpec->Ability))
		{
			OutDescription = AuraAbility->GetDescription(AbilitySpec->Level);
			OutNextLevelDescription = AuraAbility->GetNextLevelDescription(AbilitySpec->Level + 1);
			return true;
		}
	}
    
	const UAbilityInfo* AbilityInfo = UAuraAbilitySystemLibrary::GetAbilityInfo(GetAvatarActor());
	OutDescription = UAuraGameplayAbility::GetLockedDescription(AbilityInfo->FindAbilityInfoForTag(AbilityTag).LevelRequirement);
	OutNextLevelDescription = FString();
	return false;
}
```



### 在` SpellMenuWidgetController`里处理

广播选中技能信息的委托加俩变量，传一下Description

` SpellGlobeSelectedDelegate `的时候调用ASC的函数拿一下 Description然后填进去

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_FourParams(FSpellGlobeSelectedSignature, bool, bSpendPointsButtonEnabled, bool, bEquipButtonEnabled, FString, DescriptionString, FString, NextLevelDescriptionString);

private:
	void BroadcastSpellGlobeSelectedSignature(const FGameplayTag& AbilityTag, const FGameplayTag& StatusTag, int32 SpellPoints);
```



```cpp
void USpellMenuWidgetController::BindCallbacksToDependencies()
{
    // ...
    BroadcastSpellGlobeSelectedSignature(AbilityTag, StatusTag, CurrentSpellPoints);
    
    
    // ...
    BroadcastSpellGlobeSelectedSignature(SelectedAbility.Ability, SelectedAbility.Status, CurrentSpellPoints);
}

void USpellMenuWidgetController::SpellGlobeSelected(const FGameplayTag& AbilityTag)
{
    // ...
    BroadcastSpellGlobeSelectedSignature(AbilityTag, AbilityStatusTag, SpellPoints);
}

void USpellMenuWidgetController::BroadcastSpellGlobeSelectedSignature(const FGameplayTag& AbilityTag, const FGameplayTag& StatusTag, int32 SpellPoints)
{
	bool bShouldEnableSpellPointsButton = false;
	bool bShouldEnableEquipButton = false;
	ShouldEnableButtons(StatusTag, SpellPoints, bShouldEnableSpellPointsButton, bShouldEnableEquipButton);

	FString Description;
	FString NextLevelDescription;
	GetAuraASC()->GetDescriptionsByAbilityTag(AbilityTag, Description, NextLevelDescription);

	SpellGlobeSelectedDelegate.Broadcast(bShouldEnableSpellPointsButton, bShouldEnableEquipButton, Description, NextLevelDescription);
}
```



### 在` WBP_SpellMenu`里处理

`RichText_CurrentLevel`和`RichText_NextLevel`选中`Auto Wrap Text`



在`Event Construct`的`Spell Globe Selected` 之后->`RichText_CurrentLevel`和`RichText_NextLevel`的`Set Text`

![1711878942826](E:\Typora\TyporaPic\1711878942826.png)





# FireBolt Description

## 火球的技能描述

### 在` AuraProjectileSpell`里处理

伤害从DamageType表里拿到Fire类型的伤害，后面加不同属性的伤害了再写循环遍历拼字符串（

加个feature，等级提升后根据等级产生更多的火球

```cpp
public:
	virtual FString GetDescription(int32 Level) override;
	virtual FString GetNextLevelDescription(int32 Level) override;

protected:
	UPROPERTY(EditDefaultsOnly)
	int32 NumProjectiles = 5;
```



```cpp
FString UAuraProjectileSpell::GetDescription(int32 Level)
{
	const int32 Damage = DamageTypes[FAuraGameplayTags::Get().Damage_Fire].GetValueAtLevel(Level);
	if (Level == 1)
	{
		return FString::Printf(TEXT("<Title>FIRE BOLT</>\n\n<Default>Launches a bolt of fire, exploding on impact and dealing: </><Damage>%d</><Default> fire damage with a chance to burn</>\n\n<Small>Level: </><Level>%d</>"), Damage, Level);
	}
	else
	{
		return FString::Printf(TEXT("<Title>FIRE BOLT</>\n\n<Default>Launches %d bolts of fire, exploding on impact and dealing: </><Damage>%d</><Default> fire damage with a chance to burn</>\n\n<Small>Level: </><Level>%d</>"), FMath::Min(Level, NumProjectiles), Damage, Level);
	}
}

FString UAuraProjectileSpell::GetNextLevelDescription(int32 Level)
{
	const int32 Damage = DamageTypes[FAuraGameplayTags::Get().Damage_Fire].GetValueAtLevel(Level);
	return FString::Printf(TEXT("<Title>NEXT LEVEL: </>\n\n<Default>Launches %d bolts of fire, exploding on impact and dealing: </><Damage>%d</><Default> fire damage with a chance to burn</>\n\n<Small>Level: </><Level>%d</>"), FMath::Min(Level, NumProjectiles), Damage, Level);
}
```





# Cost and Cooldown in Spell Description

## 在技能描述里显示消耗和冷却

### 在` AuraGameplayAbility`里处理

加俩函数，获取技能的消耗和冷却



```cpp
protected:
	float GetManaCost(float InLevel = 1.f) const;
	float GetCooldown(float InLevel = 1.f) const;
```



```cpp
#include "AbilitySystem/AuraAttributeSet.h"


float UAuraGameplayAbility::GetManaCost(float InLevel) const
{
	float ManaCost = 0.0f;
	if (const UGameplayEffect* CostEffect = GetCostGameplayEffect())
	{
		for (const FGameplayModifierInfo& Info : CostEffect->Modifiers)
		{
			if (Info.Attribute == UAuraAttributeSet::GetManaAttribute())
			{
				Info.ModifierMagnitude.GetStaticMagnitudeIfPossible(InLevel, ManaCost);
				break;
			}
		}
	}
	
	return ManaCost;
	
}

float UAuraGameplayAbility::GetCooldown(float InLevel) const
{
	float Cooldown = 0.0f;
	if (const UGameplayEffect* CooldownEffect = GetCooldownGameplayEffect())
	{
		CooldownEffect->DurationMagnitude.GetStaticMagnitudeIfPossible(InLevel, Cooldown);
	}

	return Cooldown;
}
```



### 在` AuraDamageGameplayAbility`里处理

加个函数，根据伤害类型获取伤害数值，前面写死的内容改成函数做

```cpp
protected:
	float GetDamageByDamageType(float InLevel, const FGameplayTag& DamageType);
```



```cpp
float UAuraDamageGameplayAbility::GetDamageByDamageType(float InLevel, const FGameplayTag& DamageType)
{
    checkf(DamageTypes.Contains(DamageType), TEXT("GameplayAbilit [%s] does not contain DamageType [%s]"), *GetNameSafe(this), *DamageType.ToString());
    return DamageTypes[DamageType].GetValueAtLevel(InLevel);
}
```



### 创建` AuraFireBolt `类

放在` Aura\Public\AbilitySystem\Abilities `下

继承自` AuraProjectileSpell `

把上面在` AuraProjectileSpell `里写的内容挪到这个类下，` AuraProjectileSpell `作为投射物的基类

```cpp
public:
	virtual FString GetDescription(int32 Level) override;
	virtual FString GetNextLevelDescription(int32 Level) override;
```



```cpp
#include "Aura/Public/AuraGameplayTags.h"


FString UAuraFireBolt::GetDescription(int32 Level)
{
	const int32 Damage = GetDamageByDamageType(Level, FAuraGameplayTags::Get().Damage_Fire);
	const float ManaCost = FMath::Abs(GetManaCost(Level));
	const float Cooldown = GetCooldown(Level);
	return FString::Printf(TEXT(
		// Title
		"<Title>FIRE BOLT</>\n\n"

		// Level
		"<Small>Level: </><Level>%d</>\n"
		// ManaCost
		"<Small>ManaCost: </><ManaCost>%.1f</>\n"
		// Cooldown
		"<Small>Cooldown: </><Cooldown>%.1f</>\n\n"

		// Number of FireBolts
		"<Default>Launches %d bolts of fire, "
		"exploding on impact and dealing: </>"

		// Damage
		"<Damage>%d</><Default> fire damage with"
		" a chance to burn</>"),

		// Values
		Level,
		ManaCost,
		Cooldown,
		FMath::Min(Level, NumProjectiles),
		Damage
	);
}


FString UAuraFireBolt::GetNextLevelDescription(int32 Level)
{
	const int32 Damage = GetDamageByDamageType(Level, FAuraGameplayTags::Get().Damage_Fire);
	const float ManaCost = FMath::Abs(GetManaCost(Level));
	const float Cooldown = GetCooldown(Level);
	return FString::Printf(TEXT(
		// Title
		"<Title>NEXT LEVEL: </>\n\n"

		// Level
		"<Small>Level: </><Level>%d</>\n"
		// ManaCost
		"<Small>ManaCost: </><ManaCost>%.1f</>\n"
		// Cooldown
		"<Small>Cooldown: </><Cooldown>%.1f</>\n\n"

		// Number of FireBolts
		"<Default>Launches %d bolts of fire, "
		"exploding on impact and dealing: </>"

		// Damage
		"<Damage>%d</><Default> fire damage with"
		" a chance to burn</>"),

		// Values
		Level,
		ManaCost,
		Cooldown,
		FMath::Min(Level, NumProjectiles),
		Damage
	);
}
```



### 在`GA_FireBolt`里处理

`Parent Class`改成`AuraFireBolt`



### 在`WBP_SpellMenu`里处理

`ScrollBox`的`Padding`改成(12,0,12,0)

把`ScrollBox_Level`放到`Image_LevelScroll`和`Image_LevelBorder`之间，然后把`Image_LevelBorder`的`Visibility`设置为`Not Hit-Testable(Self Only)`，这样就不会因为滚动条的层级上方有个图片而挡住鼠标的命中检测了





# Self Deselect

## 再次点击已选中技能将取消技能的选中

### 在` SpellMenuWidgetController`里处理

存在本地的`SelectedAbility`恢复默认值

广播一下`SpellGlobeSelectedDelegate`，值全部填和初始化时一样的内容

```cpp
public:
	UFUNCTION(BlueprintCallable)
	void GlobeDeselect();
```



```cpp
void USpellMenuWidgetController::GlobeDeselect()
{
    SelectedAbility.Ability = FAuraGameplayTags::Get().Abilities_None;
	SelectedAbility.Status = FAuraGameplayTags::Get().Abilities_Status_Locked;

	SpellGlobeSelectedDelegate.Broadcast(false, false, FString(), FString());
}
```



### 在` WBP_SpellGlobe_Button`里处理

加个bool类型的变量命名为`Selected`

`Select`的时候`Selected`设置为true，`DeSelect`的时候设置为false

`OnClicked`的时候`Selected`为false的时候执行原本的内容

如果为true，则执行`DeSelect`->`BPSpellMenuWidgetController`的`GlobeDeselect`->`Play Sound 2D`选择`SFX_UI_Cancel_03`





## 修个显示描述错误的Bug

如果没选中技能或者选中的是没配置的默认技能，在更新Description的时候会用未解锁的文本

### 在` AuraAbilitySystemComponent `里处理

如果传参进来的`AbilityTag`是非法的或者`Abilities_None`，则描述直接用空字符串

```cpp
bool UAuraAbilitySystemComponent::GetDescriptionsByAbilityTag(const FGameplayTag& AbilityTag, FString& OutDescription,FString& OutNextLevelDescription)
{
	if (!AbilityTag.IsValid() || AbilityTag.MatchesTagExact(FAuraGameplayTags::Get().Abilities_None))
	{
		OutDescription = FString();
	}
	else
	{
		OutDescription = UAuraGameplayAbility::GetLockedDescription(AbilityInfo->FindAbilityInfoForTag(AbilityTag).LevelRequirement);
	}
}
```





# Equipped Spell Row Animations

## 给已装备技能栏加些动画

加个动画显示让玩家知道往哪放

### 在` WBP_EquippedSpellRow`里处理

在`WrapBox_Root`上加个Overlay命名为`Overlay_Root`，Alignment设置为Fill

`WrapBox_Root`的Alignment设置为Center，`Replace With`替换成一个`HorizontolBox`命名为`Box_Root`

加个`Image`在`Overlay_Root`下命名为`Image_OffensiveSelectionBox`设置为变量，层级在最前，Padding改成(25,0,20,0)，`Brush Image`选择`OffensiveSelectionBox`，`Render Opacity`填0

加个`Image`在`Overlay_Root`下命名为`Image_PassiveSelectionBox`设置为变量，层级在最前，Padding改成(0,0,45,0)，`Brush Image`选择`PassiveSelectionBox`，`Render Opacity`填0



#### 选中`Image_OffensiveSelectionBox`加个动画命名为`OffensiveSelectionAnimation`

加个`Image_OffensiveSelectionBox`的Track

加个`Transform`的子Track，0秒的时候Scale为(1.05,1.05)，1秒的时候Scale为(1,1)

加个`Render Opacity`的子Track，0秒的时候为1,1秒的时候为0



#### 选中`Image_OffensiveSelectionBox`加个动画命名为`HideOffensiveBox`

加个`Image_OffensiveSelectionBox`的Track

加个`Render Opacity`的子Track，0秒的时候为1,0.75秒的时候为0



#### 选中`Image_PassiveSelectionBox`加个动画命名为`PassiveSelectionAnimation`

加个`Image_OffensiveSelectionBox`的Track

加个`Transform`的子Track，0秒的时候Scale为(1.1,1.05)，1秒的时候Scale为(1,0.9)，Translation为(21,0)

加个`Render Opacity`的子Track，0秒的时候为1,1秒的时候为0



#### 选中`Image_PassiveSelectionBox`加个动画命名为`HidePassiveBox`

加个`Image_OffensiveSelectionBox`的Track

加个`Render Opacity`的子Track，0秒的时候为1,0.75秒的时候为0

加个`Transform`的子Track，0秒的时候Translation为(17,0)





# Ability Types

## 技能类型

区分是主动技能还是被动技能

### 在` AbilityInfo`里处理

技能数据里加个GameplayTag表明Type

```cpp
struct FAuraAbilityInfo
{
    // ...
    UPROPERTY(EditDefaultsOnly, BlueprintReadOnly)
	FGameplayTag AbilityType = FGameplayTag();
}
```



### 在` SpellMenuWidgetController`里处理

本地存一下是否点击了装备技能的按钮，当点击Equip按钮的时候置为true，当取消选中或者是选中了其他按钮的时候置为false，并且在变更值的时候同步给蓝图，用来播放不同的Animation

加个函数当Equip的按钮被按下时触发，广播一下选中的技能是主动还是被动



```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FWaitForEquipSelectionSignature, const FGameplayTag&, AbilityType);

public:
	UPROPERTY(BlueprintAssignable)
	FWaitForEquipSelectionSignature WaitForEquipDelegate;

	UPROPERTY(BlueprintAssignable)
	FWaitForEquipSelectionSignature StopWaitingForEquipDelegate;

	UFUNCTION(BlueprintCallable)
	void EquipButtonPressed();

private:
	bool bWaitingForEquipSelection = false;
```



```cpp
void USpellMenuWidgetController::SpellGlobeSelected(const FGameplayTag& AbilityTag)
{
    if (bWaitingForEquipSelection)
	{
		const FGameplayTag SelectedAbilityType = AbilityInfo->FindAbilityInfoForTag(AbilityTag).AbilityType;
		StopWaitingForEquipDelegate.Broadcast(SelectedAbilityType);
		bWaitingForEquipSelection = false;
	}
    // ...
}

void USpellMenuWidgetController::GlobeDeselect()
{
    if (bWaitingForEquipSelection)
	{
		const FGameplayTag SelectedAbilityType = AbilityInfo->FindAbilityInfoForTag(SelectedAbility.Ability).AbilityType;
		StopWaitingForEquipDelegate.Broadcast(SelectedAbilityType);
		bWaitingForEquipSelection = false;
	}
    // ...
}

void USpellMenuWidgetController::EquipButtonPressed()
{
	const FGameplayTag AbilityType = AbilityInfo->FindAbilityInfoForTag(SelectedAbility.Ability).AbilityType;

	WaitForEquipDelegate.Broadcast(AbilityType);
	bWaitingForEquipSelection = true;
}
```



### 在` DA_AbilityInfo`里配置

`Ability Type`都配成`Abilities.Type.Offensive`



### 在` WBP_EquippedSpellRow`里处理

`Image_OffensiveSelectionBox`和`Image_PassiveSelectionBox`的`Visibility`都设置为`Not Hit-Testable(Self & All Childs)`，不然就没法点击到下方层级的按钮了



### 在` WBP_SpellMenu`里处理

加个函数命名为`OnWaitForEquip`带个GameplayTag类型的输入参数`AbilityType`->`AbilityType`是不是Offensive并把返回值Promote to Variable命名为`IsOffensive`->`SetButtonsEnabled`都是false->`IsOffensive`为True的话`WBP_EquippedSpellRow`的`GetOffensiveSelectionAnimation`的`Play Animation`的`Num Loops to Play`填0使其一直重复，`Target`用`WBP_EquippedSpellRow`

`IsOffensive`为False的话`WBP_EquippedSpellRow`的`GetPassiveSelectionAnimation`的`Play Animation`的`Num Loops to Play`填0使其一直重复，`Target`用`WBP_EquippedSpellRow`

![1712042200505](E:\Typora\TyporaPic\1712042200505.png)



加个函数命名为`StopWaitingForEquip`带个GameplayTag类型的输入参数`AbilityType`->`AbilityType`是不是Offensive并把返回值Promote to Variable命名为`IsOffensive`->`WBP_EquippedSpellRow`的`Stop All Animations`->`IsOffensive`为True的话`WBP_EquippedSpellRow`的`GetHideOffensiveBox`的`Play Animation`的`Target`用`WBP_EquippedSpellRow`

`IsOffensive`为False的话`WBP_EquippedSpellRow`的`GetHidePassiveBox`的`Play Animation`的`Target`用`WBP_EquippedSpellRow`

![1712042192392](E:\Typora\TyporaPic\1712042192392.png)



`Event Construct`靠后的Sequence->`BPSpellMenuWidgetController`的`Assign WaitForEquipDelegate `->`OnWaitForEquip`

`BPSpellMenuWidgetController`的`Assign Stop WaitingForEquipDelegate `->`StopWaitingForEquip`



在前面之后的Sequence->`ButtonEquip`的`GetButton`->`Assign OnClicked`->`BPSpellMenuWidgetController`的`EquipButtonPressed`

![1712042226457](E:\Typora\TyporaPic\1712042226457.png)





# Equipping Abilities

## 装备技能

已装备的技能更换槽位要刷新正确，未装备的技能正常装备

### 在` AuraAbilitySystemComponent`里处理

负责具体的技能的更换

`ServerEquipAbility`负责点击按钮到Server端更新完毕ASC中的ABilities，如果这个技能是Equipped或者Unlicked状态，就可以进行更新

更新一共有如下几步，清空旧槽，添加到新槽，更新ASC里的ActivateAbilities，更新widget显示

`ClearAbilitiesOfSlot`负责根据传入的InputTag清除对应的技能，并且把被清除的技能的status置回到unlock

`ClearSlot`清除传入的GameplayAbilitySpec拥有的InputTag



`ClientEquipAbility`负责向Widget同步数据更新显示

```cpp
DECLARE_MULTICAST_DELEGATE_FourParams(FAbilityEquipped, const FGameplayTag& /*AbilityTag*/, const FGameplayTag& /*Status*/, const FGameplayTag& /*Slot*/, const FGameplayTag& /*PrevSlot*/);

public:
	FAbilityEquipped AbilityEquipped;

	FGameplayTag GetStatusFromAbilityTag(const FGameplayTag& AbilityTag);
	FGameplayTag GetInputTagFromAbilityTag(const FGameplayTag& AbilityTag);

	UFUNCTION(Server, Reliable)
	void ServerEquipAbility(const FGameplayTag& AbilityTag, const FGameplayTag& Slot);

	UFUNCTION(Client, Reliable)
	void ClientEquipAbility(const FGameplayTag& AbilityTag, const FGameplayTag& Status, const FGameplayTag& Slot, const FGameplayTag& PreviousSlot);

	void ClearSlot(FGameplayAbilitySpec* Spec);
	void SetAbilityStatus(FGameplayAbilitySpec* Spec, FGameplayTag Status);
	void ClearAbilitiesOfSlot(const FGameplayTag& Slot);
	static bool AbilityHasSlot(FGameplayAbilitySpec* Spec, const FGameplayTag& Slot);
```



```cpp
FGameplayTag UAuraAbilitySystemComponent::GetStatusFromAbilityTag(const FGameplayTag& AbilityTag)
{
	if (const FGameplayAbilitySpec* Spec = GetSpecFromAbilityTag(AbilityTag))
	{
		return GetStatusFromSpec(*Spec);
	}
	return FGameplayTag();
}

FGameplayTag UAuraAbilitySystemComponent::GetInputTagFromAbilityTag(const FGameplayTag& AbilityTag)
{
	if (const FGameplayAbilitySpec* Spec = GetSpecFromAbilityTag(AbilityTag))
	{
		return GetInputTagFromSpec(*Spec);
	}
	return FGameplayTag();
}

void UAuraAbilitySystemComponent::ServerEquipAbility_Implementation(const FGameplayTag& AbilityTag, const FGameplayTag& Slot)
{
    if(FGameplayAbilitySpec* AbilitySpec = GetSpecFromAbilityTag(AilityTag))
    {
        const FGameplayTag& PrevSlot = GetInputTagFromSpec(*AbilitySpec);
        const FGameplayTAg& Status = GetStatusFromSpec(*AbilitySpec);
        const FAuraGameplayTags& GameplayTags = FAuraGameplayTags::Get();
        
        const bool bStatusVaild = Status == GameplayTags.Abilities_Status_Equipped || Status == GameplayTags.Abilities_Status_Unlocked;
        if(bStatusVaild)
        {
            // Remove this InputTag (slot) from any Ability that has it.
            ClearAbilitiesOfSlot(Slot);
            // Clear this ability's slot, just in case, it's a different slot
            ClearSlot(AbilitySpec);
            // Now, assign this ability to this slot
            AbilitySpec.DynamicAbilityTags.AddTag(Slot);
            // Update this ability status
			SetAbilityStatus(AbilitySpec, GameplayTags.Abilities_Status_Equipped);
			// replicated this ability infos
			MarkAbilitySpecDirty(*AbilitySpec);
			// broadcast changes to widgets
			ClientEquipAbility(AbilityTag, GameplayTags.Abilities_Status_Equipped, Slot, PrevSlot);
        }
    }
}

void UAuraAbilitySystemComponent::ClientEquipAbility_Implementation(const FGameplayTag& AbilityTag, const FGameplayTag& Status, const FGameplayTag& Slot, const FGameplayTag& PreviousSlot)
{
	AbilityEquipped.Broadcast(AbilityTag, Status, Slot, PreviousSlot);
}

void UAuraAbilitySystemComponent::ClearSlot(FGameplayAbilitySpec* Spec)
{
    const FGameplayTag& Slot = GetInputTagFromSpec(*Spec);
    Spec->DynamicAbilityTags.RemoveTag(Slot);
    MarkAbilitySpecDirty(*Spec);
}

void UAuraAbilitySystemComponent::ClearAbilitiesOfSlot(const FGameplayTag& Slot)
{
	for (FGameplayAbilitySpec& Spec : GetActivatableAbilities())
	{
		if (AbilityHasSlot(&Spec, Slot))
		{
			ClearSlot(&Spec);
			// change status back to unlocked.
			SetAbilityStatus(&Spec, FAuraGameplayTags::Get().Abilities_Status_Unlocked);
		}
	}
}

bool UAuraAbilitySystemComponent::AbilityHasSlot(FGameplayAbilitySpec* Spec, const FGameplayTag& Slot)
{
    for(FGameplayTag Tag : Spec->DynamicAbilityTags)
    {
        if(Tag.MatchesTagExact(Slot))
        {
            return true;
        }
    }
    
    return false;
}

void UAuraAbilitySystemComponent::SetAbilityStatus(FGameplayAbilitySpec* Spec, FGameplayTag Status)
{
	FGameplayTag PrevStatus = GetStatusFromSpec(*Spec);
	Spec->DynamicAbilityTags.RemoveTag(PrevStatus);
	Spec->DynamicAbilityTags.AddTag(Status);
}
```



### 在` SpellMenuWidgetController`里处理

加个函数`SpellRowGlobePressed`当`WBP_EquippedSpellRow`里的`WBP_EquippedRow_Button`被`OnClicked`的时候调用，传参一个是InputTag，一个是TypeTag

`OnAbilityEquipped`里先处理一下槽里的旧技能的刷新，然后处理新技能的刷新，并且停止原本播放的Animation

```cpp
public:
	UFUNCTION(BlueprintCallable)
	void SpellRowGlobePressed(const FGameplayTag& SlotTag, const FGameplayTag& AbilityType);

	void OnAbilityEquipped(const FGameplayTag& AbilityTag, const FGameplayTag& Status, const FGameplayTag& Slot, const FGameplayTag& PreviousSlot);
```



```cpp
void USpellMenuWidgetController::BindCallbacksToDependencies()
{
    // ...
    GetAuraASC()->AbilityEquipped.AddUObject(this, &USpellMenuWidgetController::OnAbilityEquipped);
}

void USpellMenuWidgetController::SpellRowGlobePressed(const FGameplayTag& SlotTag, const FGameplayTag& AbilityType)
{
    if(!bWaitingForEquipSelection)
    {
        return;
    }
    // Check selected ability against the slot's ability type.
	// (don't equip an offensive spell in a passive slot and vice versa)
    const FGameplayTag& SelectedAbilityType = AbilityInfo->FindAbilityInfoForTag(SelectedAbility.Ability).AbilityType
;    
    if(!SelectedAbilityType.MatchesTagExact(AbilityType))
    {
        return;
    }
    
    GetAuraASC()->SeverEquipAbility(SelectedAbility.Ability, SlotTag);
}

void USpellMenuWidgetController::OnAbilityEquipped(const FGameplayTag& AbilityTag, const FGameplayTag& Status, const FGameplayTag& Slot, const FGameplayTag& PreviousSlot)
{
	bWaitingForEquipSelection = false;
    
    const FAuraGameplayTags& GameplayTags = FAuraGameplayTags::Get();
    
    FAuraAbilityInfo LastSlotInfo;
    LastSlotInfo.StatusTag = GameplayTags.Abilities_Status_Unlocked;
    LastSlotInfo.InputTag = PreviousSlot;
    LastSlotInfo.AbilityTag = GameplayTags.Abilities_None;
    
    // Broadcast empty info if PreviousSlot is a valid slot. Only if equipping an already-equipped spell
	AbilityInfoDelegate.Broadcast(LastSlotInfo);
    
    FAuraAbilityInfo Info = AbilityInfo->FindAbilityInfoForTag(AbilityTag);
    Info.StatusTag = Status;
    Info.InputTag = Slot;
    AbilityInfoDelegate.Broadcast(Info);
    
    StopWaitingForEquipDelegate.Broadcast(AbilityInfo->FindAbilityInfoForTag(AbilityTag).AbilityType);
}
```



### 在` WBP_EquippedRow_Button`里处理

加个`GameplayTag`类型的变量命名为`AbilityType`，默认值为None，避免当`OnAbilityEquipped`把旧槽位设置为`Abilities.None`时一起清空掉还没设置的那些按钮的背景图之类的内容

`Button_Ring`设置为变量

`Event Widget Controller Set`的最后->`Button_Ring`的`Assign On Clicked`->`BPSpellMenuWidgetController`的`SpellRowGlobePressed`参数用`InputTag`和`AbilityType`

![1712048995649](E:\Typora\TyporaPic\1712048995649.png)



`Event AbilityInfoDelegate`里->`AbilityTag`如果是`Abilities.None`的话执行`ClearGlobe`，否则的话走正常的SetBrush的内容，避免当`OnAbilityEquipped`把旧槽位设置为`Abilities.None`时用默认初始化的AuraAbilityInfo导致没有材质Asset的部分

![1712049020947](E:\Typora\TyporaPic\1712049020947.png)





### 在` WBP_EquippedSpellRow`里处理

在PreConstruct的时候给每个按钮配置一下`AbilityType`为`Abilities.Type.XXX`





# Updating the Overlay When Equipping Abilities

## 装备技能的时候同步一下Overlay上的显示

### 在` OverlayWidgetController`里处理

监听一下ASC的委托

```cpp
private:
	void OnAbilityEquipped(const FGameplayTag& AbilityTag, const FGameplayTag& Status, const FGameplayTag& Slot, const FGameplayTag& PreviousSlot) const;
```



```cpp
#include "AuraGameplayTags.h"

void UOverlayWidgetController::BindCallbacksToDependencies()
{
    // ...
    if (UAuraAbilitySystemComponent* AuraASC = GetAuraASC())
	{
		AuraASC->AbilityEquipped.AddUObject(this, &UOverlayWidgetController::OnAbilityEquipped);
        // ...
    }
}

void UOverlayWidgetController::OnAbilityEquipped(const FGameplayTag& AbilityTag, const FGameplayTag& Status, const FGameplayTag& Slot, const FGameplayTag& PreviousSlot) const
{
	const FAuraGameplayTags& GameplayTags = FAuraGameplayTags::Get();
	
	FAuraAbilityInfo LastSlotInfo;
	LastSlotInfo.StatusTag = GameplayTags.Abilities_Status_Unlocked;
	LastSlotInfo.InputTag = PreviousSlot;
	LastSlotInfo.AbilityTag = GameplayTags.Abilities_None;
	// Broadcast empty info if PreviousSlot is a valid slot. Only if equipping an already-equipped spell
	AbilityInfoDelegate.Broadcast(LastSlotInfo);

	FAuraAbilityInfo Info = AbilityInfo->FindAbilityInfoForTag(AbilityTag);
	Info.StatusTag = Status;
	Info.InputTag = Slot;
	AbilityInfoDelegate.Broadcast(Info);
}
```





### 在` WBP_SpellGlobe `里处理

`Receive Ability Info`里在检查InputTag是否相同之后->`AbilityTag`是否和`Abilities.None`相同，如果相同则`ClearGlobe`->`CooldownTag`设置为None，如果不同则执行原本的`Set Brush`的内容







# Globe Reassigned

## 装备完技能后取消SpellMenu中SpellGlobe的选中效果

### 在` SpellMenuWidgetController`里处理

加个委托用于按钮本身监听处理取消选中

再调用一下DeSelect处理一下

```cpp
DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FSpellGlobeReassignedSignature, const FGameplayTag&, AbilityTag);

public:
	UPROPERTY(BlueprintAssignable)
	FSpellGlobeReassignedSignature SpellGlobeReassignedDelegate;
```



```cpp
void USpellMenuWidgetController::OnAbilityEquipped(const FGameplayTag& AbilityTag, const FGameplayTag& Status, const FGameplayTag& Slot, const FGameplayTag& PreviousSlot)
{
    // ...
    SpellGlobeReassignedDelegate.Broadcast(AbilityTag);
    GlobeDeselect();
}
```



### 在` WBP_SpellGlobe_Button`里处理

加个函数命名为`OnSpellGlobeReAssigned`带个GameplayTag类型的输入参数`AbilityTag`->`AbilityTag`是否和`AbilityTag`相同->`DeSelect`->`Play Sound 2D`选择`sfx_UI_Unlock_SelectSkill`

![1712051217818](E:\Typora\TyporaPic\1712051217818.png)



`Event Widget Controller Set`->`BPSpellMenuWidgetController`的`Assgin SpellGlobeReassignedDelegate`

![1712051211956](E:\Typora\TyporaPic\1712051211956.png)





# Unbinding Delegates

## 处理一些被重复多次绑定的委托

`Event Widget Controller Set`后绑定的委托都存在每set一次Widget controller就绑定一份，导致越来越多

### 在` WBP_SpellGlobe_Button`里处理

`Event Destruct`->`BPSpellMenuWidgetController`的`Convert to Validated Get`的`UnBind all Events from SpellGlobeReassignedDelegate`















